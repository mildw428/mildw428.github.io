---
layout: default
title: 07. Real MySQL 8.0
parent: Real MySQL 8.0
---
# 7장
---
# 데이터 암호화

## MySQL 서버의 데이터 암호화

![[Pasted image 20240429221226.png|400]]
데이터베이스 서버와 디스크 사이의 데이터를 읽고 쓰기 지점에서 암호화 또는 복호화를 수행한다. 그래서 MySQL 서버에서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요치 않다.

데이터 암호화 기능이 활성화 돼 있다고 하더라도 사용자 입장에서는 아무런 차이가 없다. 이러한 방식을 TDE(Transparent Data Encryption)라고 한다. 또는 Data Rest Encryption이라고도 하는데, 데이터가 전송 단계가 아닌 저장 단계에서만 암호화된다는 의미로 사용된다.

### 2단께 키 관리
MySQL TDE에서 암호화 키는 키링 플로그인에 의해 관리된다.
- keyring_file File-Based 플러그인 (커뮤니티 에디션은 해당 플러그인만 가능)
- keyring_encrypted_file Keyring
- keyring_okv KMIP 플러그인
- keyring_aws Amazon Web Services Keyring 플러그인

다양한 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다르다.
![[Pasted image 20240429221815.png|400]]
MySQL 서버의 키링 플러그인은 2단계 키 관리 방식을 사용한다.

MySQL서버의 데이터 암호화는 마스터 키와 테이블 스페이스 키라는 두 종류의 키를 가지고 있는데, 테이블스페이스 키는 프라이빗 키 라고도 한다.

MySQL서버는 외부 키 관리 솔루션 (그림의 HashiCrop 등)에서 마스터 키를 가져오고, 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급한다.

그리고 MySQL 서버는 마스터 키를 이용해 테이블스페이스키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.

이렇게 생성된 테이블 스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다. (외부로 노출될 일이 없기 때문에 보안에 취약하지 않음)

하지만 마스터 키는 외부로 노출될 가능성이 있기 때문에 주기적으로 변경해야 한다.

마스터키를 변경하려면 기존의 테이블 스페이스 키를 복호화 한 후에 새로운 마스터 키로 다시 암호화 한다.

이런 방식을 하는건 시스템 부하를 피하기 위해서이다. 테이블 스페이스 키를 바꿔야 한다면 테이블의 모든 데이터를 복호화 한 후에 스페이스 키를 새로 발급하여 다시 암호화 해야하는 엄청난 작업이 발생한다.

### 암호화와 성능
쿼리가 InnoDB 버퍼 풀에 존재하지 않는 데이터를 읽어야 하는 경우 복호화 과정을 거치기 때문에 복호화 시간동안 쿼리가 지연된다. 그리고 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화 되어야하기 떄문에 처리가 지연된다.

하지만 데이터 페이지 저장은 백그라운드로 처리되기 때문에 실제 사용자 쿼리가 지연되는것이 아니다.

AES암호화 알고리즘은 암호화하고자 하는 평문의 길이가 짧은 경우 암호화 키의 크기에 따라 암호화된 결과의 용량이 더 커질 수 있지만, 이미 데이터 페이지는 암호화 키보다 훨씬 크기 때문에 암호화 결과가 평문의 결과와 동인한 크기의 암호문을 반환한다.

같은 테이블에 암호화와 압축이 동시에 적용되면 서버는 압축 -> 암호화를 적용한다

이유
- 암호화된 결과문은 랜덤바이트를 가진다. 이는 압축률을 상당히 떨어트린다
- 암호화 먼저 실행되고 압축을 실행한다면 읽었을때 버퍼 풀의 데이터가 암호화 되어있어 사용할 때 마다 복호화를 해야한다

### 암호화와 복제
서버 복제에서 레플리카 서버는 소스 서버와 데이터를 동기화 하기 때문에 실제 데이터 파일도 동일할 것이라 생각할 수 있다. 하지만 TDE를 이용한 암호화 사용시 마스터 키와 테이블스페이스 키는 그렇지 않다.

원격으로 키 관리 솔루션을 사용하느 경우에도 소스 서버와 레플리카 서버는 서로 다른 마스터키를 갖도록 설정해야 한다. 마스터 키 자체가 레플리카로 복제되지 않는다.
테이블스페이스 키 또한 마찬가지다. 때문에 복제 멤버들의 데이터 파일은 암호화 되기 전 값은 동일하더라도 암호화 된 데이터는 완전히 달라진다.

## 테이블 암호화
키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지만 담당하기 때문에 어떤 키링 플러그인을 사용하든 암호화된 테이블을 생성하고 활용하는 방법은 모두 같다.

### 테이블 생성
TDE를 이용하는 테이블은 다음과 같이 생성할 수 있다.
```sql
CREATE TABLE tab_encrypted (
	id INT,
	data VARCHAR(100),
	PRIMARY KEY(id)
) ENCRYPTION='Y';
```
일반 테이블 생성 쿼리에 `ENCRYPTION='Y'`옵션만 추가해주면 된다.

```sql
SELECT table_schema, table_name, create_options
FROM infromation_schema.tables
WHERE table_name='tab_encrpyted';
```
암호화 된 테이블만 검색할 때는 `infromation_schema`를 사용하면 된다.

### 응용 프로그램 암호화와의 비교
응용 프로그램에서 직접 암호화해서 MySQL 서버에 저장하는 경우도 있는데, 이 경우 저장되는 컬럼 값이 이미 암호화된 것인지 여부를 MySQL서버는 인식하지 못한다. 때문에 암호화된 컬럼은 인덱스를 생성하더라도 인덱스의 기능을 100% 활용할 수 없다.
![[Pasted image 20240429224556.png|400]]
![[Pasted image 20240429224608.png|400]]
날짜 범위 검색 등의 불편함

응용 프로그램의 암호화와 MySQL 서버의 암호화 기능중 선택해야 하는 상황이라면 고민할 필요 없이 MySQL 서버의 암호화 기능을 선택할 것을 권장한다.

### 테이블 스페이스 이동
테이블을 다른 서버로 복사해야 하는 경우
또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면
테이블 스페이스 이동 기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠르다.

MySQL서버에서 다음과 같이 FLUSH TABLES 명령으로 테이블스페이스를 익스포트할 수 있다.
```sql
FLUSH TABLES source_table FOR EXPORT;
```
해당 명령이 실행되면 다음과 같은 테이블 복사 과정을 거친다.
- MySQL서버는 source_table의 저장되지 않은 변경 사항을 모두 디스크로 기록하고, 더이상 source_table에 접근할 수 없게 잠금을 건다.
- 그와 동시에 source_table의 구조를 source_table.cfg파일로 기록해둔다.
- 그러면 source_table.ibd 파일과 source_table.cfg 파일을 목적지 서버로 복사한다.
- 복사가 완료되면 UNLOCK TABLES 명령을 실행해 source_table을 사용할 수 있게 하면 된다.


그런데 TDE가 적용되어 암호화된 테이블의 경우 원본 MySQL서버와 목적지MySQL 서버의 암호화 키가 다르기 때문에 하나 더 신경써야 할 부분이 있다. 

- 임시로 사용할 마스터 키를 발급해서 source_table.cfp라는 파일로 기록한다. 
- 그리고 암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화한 후, 임시로 발급한 마스터 키를 이용해 다시 암호화해서 데이터 파일의 헤더 부분에 저장한다.
- 그래서 암호화된 테이블의 경우 테이블스페이스 이동 기능을 사용할 때는 반드시 데이터 파일과 임시 마스터 키가 저장된 `.cpf`파일을 함께 복사해야 한다. 없다면 복구가 불가능하다

## 언두 로그 및 리두 로그 암호화
테이블 암호화를 적용하더라도 디스크로 저장되는 데이터만 암호화되고 서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리된다. 리두 로그, 언두 로그, 그리고 복제를 위한 바이너리 로그에는 평문으로 저장되는데, `innodb_undo_log_encrypt` 시스템 변수와 `innodb_redo_log_encrypt`시스템 변수를 이용해 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있다.

옵션을 활성화 한다고 해서 기존에 사용하던 모든 리두 로그나 언두 로그의 데이터를 해당 시점에 한번에 암호화해서 다시 저장할 수 없다. 반대로 비활성화 한다고 해서 기존의 암호화 되어있던 로그들이 복호화되어 다시 저장되지 않는다. 때문에 암호화에 진행된 키는 상황에 따라 몇일 또는 몇달동안 필요할 수 있다.

리두 로그와 언두 로그 데이터 모두 각각의 테이블스페이스 키로 암호화된다. 테이블 스페이스 키는 마스터 키로 다시 암호화 되며 리두 로그 파일과 언두 로그 파일의 헤더에 저장된다.

```sql
SHOW GLOBAL VARIABLES LIKE 'innodb_redo_log_encrypt';
```

## 바이너리 로그 암호화
바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고, 메모리 내부 또는 서버와 레플리카 서버간의 네트워크 구간에서 로그 데이터를 암호화 하지 않는다. 네트워크 구간 사이에서 암호화가 필요하다면 SSL을 사용한다.

### 바이너리 로그 암호화 키 관리
![[Pasted image 20240430222249.png|400]]

바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키(file key)로 암호화해서 디스크에 저장하고, 파일 키는 "바이너리 로그 암호화 키"로 암호화 해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장한다.

### 바이너리 로그 암호화 키 변경
```sql
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```
바이너리 로그 암호화 키가 변경되면 다음과 같은 과정을 거친다.
1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치 (새로운 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키로 암호화해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거
