---
layout: default
title: 14. 서버리스
parent: aws
---
# 14. 서버리스
---

서버리스 서비스를 사용하는 개발자는 서버를 관리할 필요가 없다.

서버리스는 서버가 보이지 않거나 서버를 프로비저닝 하지 않는것이다.

Lambda, DynamoDB, Cognito, API Gateway, S3, SNS, SQS, Aurora, Fargate(ECS) 등

---

## Lambda

최대 15분
온디맨드 (함수가 실행되는 동안만 청구)
스케일링이 자동화

장점
- 쉬운 가격책정
- 다양한 aws 서비스와 통합 가능
- 여러가지 프로그래밍 언어 지원
- 쉬운 cloudwatch와의 모니터링 통합
- 함수당 최대 10gb의 램을 프로비저닝 할 수 있다만약 함수의 ram을 증가시키면 cpu 및 네트워크의 품질과 성능도 함께 향상된다
- 컨테이너 이미지 지원
	- 해당 컨테이너가 lambda 런타임 api를 구현하지 않으면 ecs나 fargate에서 컨테이너를 실행해야한다

서버리스 섬네일 생성시 lambda와 s3를 사용해서 해결할 수 있다

---

### 제한

한도는 리전당 존재
메모리 할당량은 128mb ~ 10gb
메로리는 1mb씩 증가한다
최대 실행시간은 15분이다
환경변수는 4kb까지 가질 수 있다
/tmp 폴더에 용량이 있으며 크기는 최대 10gb이다
람다 함수는 최대 1000개까지 동시 실행이 가능하다

배포한도
압축 시 최대 크기는 50mb
압축하지 않았을 때는 250mb이다
이 용량이 넘는경우 /tmp 공간을 사용해야한다.

---

### Customization At The Edge
엣지에서의 사용자 지정

보통은 함수와 애플리케이션을 특정 리전에서 배포하지만, CloudFront를 사용할 때는 엣지 로케이션을 통해 배포한다

애플리케이션에 도달하기 전에 엣지에서 로직을 실행하도록 하는것을 엣지 함수라고함
CloudFront배포에 연결하는 코드이다

사용자 근처에서 실행하여 지연시간을 최소화하는 것이 목적이다

두가지 종류
CloudFront
Lambda@Edge


엣지함수 -> 서버 관리가 필요없다
전역으로 배포되기 때문

CloudFront 함수의 활용과 원리

클라이언트는 클라우드 프론트에 뷰어 요청을 하고 클라우드 프론트는 오리진에 요청하여 그 응답을 클라이언트로 보낸다.
클라우드프론트는 뷰어(클라이언트)에게 응답하기전에 응답을 수정할 수 있다.
뭐라는거야? 그래서 왜있는건데?

Lambda@Edge
기능이 더 많다
Node.js 나 Python으로 작성
초당 수천개의 요청을 처리
모든 CloudFront요청 및 응답을 변경할 수 있다
함수는 us-east-1리전에서만 작성 가능
함수를 작성하면 모든 로케이션에 해당 함수를 복사한다

차이는 런타임 지원
cloudfront는 js
lambda@edge는 node.js 와 python 지원

cloudfront는 수백만개의 요청 처리
lambda@edge는 수천개 수준

cloudfront 함수의 최대 실행시간은 1밀리초 미만
lmbda@edge는 실행에 5~10초 소요

cloudfront는 캐시 키를 정규화
요청 속성을 변환하여 최적의 캐시 키를 생성
요청이나 응답에 http헤더를 삽입, 수정, 삭제 조작
url을 다시 쓰거나 리디렉션
jwt를 생성하거나 검증하는 요청 인증 및 권한 부여

lmbda@edge는 cpu와 메모리가 증가하므로 여러 라이브러리를 로드할 수 있다
타사 라이브러리에 코드를 의존시킬 수 있다
대규모 데이터 통합도 수행가능
파일 시스템이나 http요청 본문에도 바로 엑세스 가능하다

---

### Lambda 네트워킹

람다 함수를 시작하면 vpc외부에서 시작된다.
그래서 람다는 redis, elastiCache, ELB 에 접근 할 수 없다

해결하려면 vpc에서 lambda 함수를 시작하면된다
이를 위해서
vpc id lambda 함수를 시작하려는 서브넷을 지정하고 lambda함수에 보안 그룹을 추가해야한다.

람다에는 rds프록시를 연결해야한다

---

### 람다 호출 및 이벤트 알림

데이터베이스 인스턴스 안의 람다를 호출 할 수 있다!?
그래서 데이터베이스 안에서 일어나는 데이터 이벤트를 처리할수있다?!
RDS 인스턴스로부터 람다 함수로 오는 인바운드 트래픽을 허용해 줘야한다
RDS는 람다 호출에 필요한 권한을 갖고있어야한다
DB안의 데이터에 관한 정보는 보내지 않는다

RDS이벤트 알림을 사용하는 것과 아주 다르다
> 뭐더라?

---

### DynamoDB

완전 관리형 DB이다
데이터가 다중 az간에 복제되므로 가용성이 높다
NoSQL
관계형은 아니지만 트랜잭션 지원 기능이 있다
비용이 적게 들고 오토 스케일링 기능이 탑제
유지 관리나 패치 없이도 항상 사용 가능
프로비저닝 필요 없음
테이블의 용량만 설정하면됨
엑세스가 빈번한것과 그렇지 않은것으로 클래스를 나누어 저장함
DynamoDB 항목의 최대 크기는 400kb이므로 큰 객체를 저장할 때는 적합하지 않다

다양한 데이터 유형을 지원한다
문자열, 숫자 등등 일반적인것
목록, 지도와 같은 문서 유형과 세트 유형도 지원한다

DynamoDB를 사용하려면 읽기/쓰기 용량모드도 설정 해야한다

기본 프로비저닝된 모드는 미리 용량을 프로비저닝한다. 해당 기능은 로드를 예측 할 수 있고 비용 절감을 원할때 사용

온디맨드 모드는 읽기 / 쓰기 용량이 워크로드에 따라 자등으로 확장된다
로드가 급격히 증가하는 경우에 유용하다

수천개의 상태에서 수백만개의 트랙잭션으로 1분내로 확장해야하는 경우 프로비저닝은 적합하지않다


### DAX
DynamoDB Accelerator 

고가용성의 완전 관리형 무결절 인메모리 캐시
테이블에 읽기 작업이 많을때 dax클러스터를 생성하고 데이터를 캐싱하여 읽기 혼잡을 해결한다

dax클러스터는 기존 dynamoDB api와 호환되므로 애플리케이션 로직을 변경할 필요가 없다

ElastiCache가 아니라 DAX를 사용하는 이유는?
쿼리와 스캔캐시를 처리하는데 유용

예를들어
집계 결과는 ElastiCache가 좋고
대용량의 연산을 저장할때는 DynamoDB가 좋다
DynamoDB에 캐싱 솔루션을 추가할때는 DAX를 사용한다

#### DynamoDB Stream
보존 기간이 24시간이고 소비자 수가 제한된다.
??

lambda 트리거와 함께 사용하면 좋다

으악 듣기싫어
```
222. Amazon DynamoDB 심화기능
```
나중에 다시 듣자

---

## API Gateway

클라이언트가 직접 lambda 함수를 지연 호출할 수 있게 하려면 클라이언트에게 IAM권한이 있어야 한다

클라이언트와 Lambda 함수 사이에 애플리케이션 로드밸런서 배치 필요 혹은 API Gateway를 사용한다

API Gateway를 사용하는 이유는 HTTP엔드포인트 뿐만아니라 인증 사용량계획, 개발 단계 등의 기능을 제공한다

API Gateway + Lambda = 완전 서버리스 애플리케이션

Websocket 프로토콜도 지원하므로 실시간 스트리밍이 가능하다

인증, 권한부여 등 보안 기능을 api gateway에 활성화 할 수 있다

과도한 요청에 대해 스로틀링 가능

스웨거와 같은 api 정의 가능

api 응답 캐싱 가능

속도 제한 기능


API Gateway 배포 방법

- 엣지 최적화
	- 글로벌 클라이언트용
	- 전세계 누구나 접근 가능
	- 모든 요청이 cloudFront엣지 로케이션을 통해 라우팅되므로 지연시간 개선
- 자체 CloudFront배포
	- 엣지 최적화와 동일한 결과
	- 캐싱 전략과 CloudFront설정에 더많은 권한을 가질 수 있다
- 프라이빗 배포
	- VPC내에서만 액세스 가능
	- ENI같은 인터페이스 VPC엔드포인트를 사용한다
> ENI가 뭐더라? 엘라스틱 네트워크 인스턴스?


보안
- IAM 사용
- Amazon Cognito
- HTTPS
	- 사용자 지정 도메인 이름을 aws certificate manager(ACM)과 통합할수있다.

Route53에 CNAME이나 A-별칭 레코드를 설정해 도메인 및 api gateway를 가리키도록 해야한다

---

## Step Functions
서버리스 워크플로를 시작적으로 구성할 수 있는 기능

람다 함수를 오케스트레이션 하는데 활용

그래프를 통해 단계별로 다음 수행하는 작업을 정의

시퀀싱, 병행 실행, 조건 설정, 타임아웃, 에러 처리 등 기능이있다

람다 뿐 아니라 ec2, ecs, 온프레미스 서버, api gateway, sqs 등 다양한 aws서비스를 워크플로에 넣을 수 있다

---

## Amazon Cognito
사용자에게 웹 및 모바일 앱과 상호작용 할 수 있는 자격 증명을 부여한다

두 종류의 하위 서비스
- 가입 기능을 제공하는 사용자 풀
	- API Gateway 및 애플리케이션 로드 밸런서와 원활히 통합 된다
- 페더레이션 자격 증명 자격 증명 풀
	- 앱에 등록된 사용자에게 임시 aws자격 증명을 제공
	- 일부 aws리소스에 직접 액세스 할 수 있도록 해준다
	- 사용자 풀과 원활히 통합된다


수백명의 사용자, 모바일 사용자, SAML을 통한 인증과 같은 키워드가 나오면 Cognito를 설명하는 것이다

#### Congnito 사용자 풀 (CUP)
웹 및 모바일 앱을 대상으로 하는 서버리스 사용자 데이터베이스이다

멀티팩터 인증이 가능하다
facebook or google과 통합할수있어 소셜 로그인 가능하다

Cognito 사용자 풀은 api gateway나 애플리케이션 로드 밸런서와 통합된다

>api gateway를 예로 들면
>사용자는 congnito 사용자 풀에 접속해서 토큰을 받고 검증을 위해 토큰을 api gateway에 전달한다. 확인이 끝나면 사용자 자격 증명으로 변환되어 백엔드의 lambda 함수로 전달된다


다른 방법으로 애플리케이션 로드밸런서를 사용해서 로그인 여부를 확인 후 백엔드로 리다이렉트 하는 방법도 있다

#### 자격증명 풀 (페더레이션 자격증명)
사용자에게 자격증명을 제공하지만 api gateway나 로드밸런서를 액세스하지 않고 임시 aws 자격증명을 사용해 aws계정에 직접 액세스한다

직접 또는 api gateway를 통해 서비스에 액세스할 수도 있다

원한다면 iam역할을 정의할 수도 있다

