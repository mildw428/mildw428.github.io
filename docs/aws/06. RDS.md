---
layout: default
title: 06. RDS
parent: aws
---
# 06. RDS
---

관계형 데이터베이스 서비스

- Postgres
- Mysql
- MariaDB
- Oracle
- Microsoft SQL server
- Aurora(AWS properietary database)

- rds는 데이터베이스 프로비저닝과 기본 운영체제 패치가 자동으로 되어있다 (완전 자동화)
- 지속적으로 백업이 생성됨
- 성능을 대시보드로 확인 가능
- 읽기전용 복사를 통해 성능 향상 
- 재해 복구
- 다중 AZ
- 유지기간에 업그레이드 가능
- 수직 수평 스케일링 가능

단점은 ssh액세스가 불가능

- rds db를 만들때 스토리지를 설정하는데 공간이 부족하면 오토스케일링 기능으로 이를 감지해 스토리지를 확장한다. db를 다운시키는 작업따윈 필요없다
- 최대 스토리지를 정하는 작업이 필요하고 현재상태에서 10퍼센트가 남은경우 5분이 지났을때 (설정한지 6시간이 지났을때)오토스케일링이 동작한다
- 모든 엔진에서 지원한다

---

읽기전용 복제본
- 15개까지 가능
- 동일한 가용영역 또는 가용영역이나 리전을 결쳐서 생성 할 수 있다. 
- 비동기식 복제
- 읽기복제본은 db로 승격시킬수있다
- 비용
	- 데이터가 이동할떄 비용 발생
	- 동일한 리전 내에 있을때는 비용이 발생하지 않는다


다중 AZ
- 재해 복구에 사용
- 마스터 db는 대기 인스턴스에 동기식으로 복제
- 어플리케이션은 DNS를 통해 db에 접근한다
- 마스터 db에 문제가 생기면 동기식으로 연결된 db가 장애대응을 한다
- 스탠바이 db는 대기 목적으로만 사용한다
- 다중 az로 설정할 수 있다
- 단일 az에서 다중az로 바꿀때는 downtime이 없다
- 과정은 메인db에서 스냅샷을찍어 스탠바이db를 생성후 메인db와 스탠바이db가 싱크를 맞춘다

---

RDS custom
- 오라클, microsoft만 지원
- 데이터베이스와 운영체제 관리자 전체 권한을 갖게된다
- SSH SSM 접근할 수 있다
- 자동화를 꺼두는게 좋다
- SSH접근이 가능하기때문에 오류가 날 가능성이 많다
- 스냅샷을 찍어두는게 좋다

---

## 오로라
시험에 잘나옴
자세히 알필요없음
동작 이해 필요

- Postgres, Mysql 호환
- 클라우드 최적화
- mysql보다 5배 postgres의 3배 성능
- 스토리지를 자동 증가 (시작은 10GB 최대 128TB)
- Sysops
- 15개까지 읽기복사
- 복사속도도 빠름
- 가용성이 좋음
- rds에비해 20퍼 더비쌈

- 높은가용성, 읽기 스케일링
- 3개의 az에 걸쳐 무언가 기록할때 6개의 사본 저장
- 복사시 쓰기는 4개 읽기는 3개만 필요
- 일부 데이터가 문제가있으면 백엔드에서 자가복구함
- 수백개의 볼륨을 사용하여 리스크 감소
- 오로라는 rds의 다중 az와 유사하다
- 오로라에도 마스터가 존재하고 여기서 쓰기를 받는다
- 마스터가 동작하지않으면 30초안에 장애조치가 발동
- 읽기복제는 15개까지 가능
- 마스터에 문제가생기면 다른db가 마스터가 된다
- 리전간 복제 제공

오로라 클러스터
리드 엔드포인트 라이트 엔드포인드
라이트 엔드포인트는 마스터에만 연결
리드 엔드포인트는 복사된 리드 db에 로드밸런싱으로 연결


### 복제본 오토 스케일링
클라이언트
세개의 오로라 인스턴스
- 1개의 라이터 엔드포인트를 통한 쓰기용
- 2개의 리더 엔드포인트를 통한 읽기용
- 많은 읽기 요청 발생 & cpu 사용량 크게 증가
- 이때 읽기용 db 복제 오토스케일링
- 인스턴스가 증가할때 더 큰 스펙의 인스턴스를 생성한다
- 이렇게 하는 이유는 특정 복제본에 대해 분석 쿼리를 실행하는것이 더 좋을것 같아서이다
- 더 큰 스펙의 인스턴스를 생성한 이후 커스텀 엔드포인트를 만들어 이들을 연결한다
- 기존에 사용하던 엔드포인트는 사용하지않게된다
- 기존의 엔드포인트에 연결된 인스턴스는 사라지지않지만 사용하지않게된다
- (분석 쿼리는 뭔데?)

### 오로라 서버리스

- 실제 사용량에 따라 자동화된 데이터베이스 인스턴스화 및 오토스케일링을 제공
- 워크로드가 드물거나 간헐적이거나 예측할 수 없는 경우에 유용
- 용량 계획을 세울 필요가 없다
- 초당 사용량으로 요금을 지불 (비용에 효율적)
- 클라이언트는 오로라에서 관리하는 프록시 플릿과 대화하게 된다.
- 백엔드에서는 서버리스 방식으로 워크로드에따라 많은 오로라 인스턴스가 생성된다
- 따라서 용량을 미리 프로비저닝 할 필요가 없다

### 오로라 멀티 마스터

- 라이터 노드에 대해 지속적인 쓰기 가용성을 원하는 경우
- 즉 오로라 클러스터에서 모든 오로라 인스턴스는 라이터 노드이다
- 하나의 새 마스터가 있고 그 마스터가 실패한경우 다른 인스턴스가 마스터가 된다
- 클라이언트는 여러개의 오로라 인스턴스에 대한 여러 데이터베이스 연결을 유지할 수 있다

### 글로벌 오로라
리전간 읽기 복제본이 있는경우
재해복구용
설치가 간단
글로벌 데이터베이스 설정은 권장되는 방법이다
기본 리전에서 읽기 및 쓰기가 모두 일어난다
하지만 최대 5개의 보조 읽기 리전도 있다. 복제 지연이 1초 미만
보조 리전당 최대 15개의 읽기 복제본을 설정 할 수 있다. 전세계 읽기 워크로드 지연시간을 줄일 수 있다
재해가 일어난 경우 다른 리전으로 복구하는데 1분 미만이 걸린다

>주의
>오로라 글로벌 데이터베이스의 데이터 리전 간에 복제하는데 평균 1초 미만이 소요된다
>해당 문장이 나오면 글로벌 오로라를 사용하라는 뜻


### 오로라 머신 러닝

머신러닝 서비스 간의 간단하고 최적화된 안전한 통합이다

- SageMaker
	- 백엔드에서 모든 종류의 머신러닝 모델을 사용할 수 있게 해준다
- Amazon Comprehend
	- 감성 분석을 할 수 있다

오로라가 이들과 통합되어있다 정도만 알면 된다

사용 사례
- 사기 탐지
- 광고 타겟팅
- 감정 분석
- 제품 추천

백엔드가 사용자의 데이터를 sagemaker에 데이터를 보내면, 이를 comprehend를 통해 분석해서 예측 데이터를 반환한다.

---

## 백업

- 자동화된 백업
	- rds서비스가 자동으로 매일 데이터베이스의 전체 백업을 수행한다. (데이터 베이스 백업 기간동안)
	- 5분마다 트랙잭션 로그가 백업된다
	- 자동 백업을 통해 언제라도 5분전으로 복원할 수 있다
	- 자동 백업 보존 기간은 1~35일 사이로 설정 가능
	- 이 기능을 사용하지 않으려면 0으로 설정한다
- 수동 데이터베이스 스냅샷
	- 수동으로 한백업을 원하는 기간동안 유지
	- 자동 백업은 만료되는 반명 수동 스냅샷은 원하는 기간동안 보관할 수 있다
	- 백업은 비용을 절감하고싶을때도 진행한다
		- 사용한 데이터를 스냅샷으로 만든다음 원본 데이터베이스를 삭제하면 비용을 절감할 수 있다

오로라
- 자동화된 백업
	- 1~35일까지 가능, 하지만 비활성 불가능
	- rds는 비활성이 가능하다
	- 시점 복구 기능이 있다
- 수동 스냅샷
	- 사용자가 수동으로 트리거할 수 있으며, 원하는 기간동안 유지할 수 있다

rds백업과 오로라 백업은 매우 비슷하다


### 복원 옵션

- 새 데이터배이스
- S3에서 mysql데이터베이스를 복원할 수 있다
	- 온프레미스 데이터베이스의 백업을 생성한 다음 객체 스토리지인 amazon S3에 배치
	- S3에서 백업 파일을 복원
- mysql 오로라 클러스터로 복원하려는 경우
	- 온프레미스 데이터베이스를 다시 백업
	- XtraBackup이란걸 사용해서 가능
	- 백업 파일을 S3로 보내서 백업을 복원할 수 있다
	- 차이점은 rds mysql로 복원할때는 데이터베이스 백업만 있으면 되지만 오로라는 XtraVackup으로 백업 한다음 S3에서 오로라 db 클러스터로 백업해야한다

근데 복원 옵션이라면서 왜자꾸 백업백업 거림?

>온-프레미스는 무엇일까요?
>기업이 자체적으로 IT 인프라를 소유, 관리 및 운영하는 경우를 '온-프레미스'라고 합니다.


### 오로라 데이터베이스 복제

기존 데이터베이스 클러스터에서 새로운 오로라 데이터베이스 클러스터를 생성할 수 있다

copy on write 프로토콜을 사용한 복제는 매우 빠르다

처음 데이터베이스 복제본을 만들때는 원래 데이터베이스 클러스터와 동일한 데이터 볼륨을 사용하게 된다
데이터를 복사하지않는다
새로운 db클러스터가 생성되면 스토리지가 할당되고, 데이터가 복사 및 분리된다

데이터베이스 복제는 빠르고 비용 효율적이며, 프로덕션 데이터베이스에 영향을 주지 않는다

스냅샷 및 복원 기능도 필요없다

---

## RDS Security

- at-rest encryption
	- RDS 및 오로라 데이터베이스에 저장된 데이터를 암호화 할 수 있다
	- KMS를 사용해 마스터와 모든 복제본의 암호화가 이루어진다
	- 마스터db가 암호화 되어있지 않다면 읽기 전용 복제본은 암호화 할 수 없다
	- 암호화 되어있지 않은 기존 데이터베이스를 암호화 하려면 암호화 되지 않은 데이터베이스의 데이터베이스 스냅샷을 가지고 와서 암호화된 데이터베이스 형태로 데이터베이스 스냅샷을 복원해야 한다
- in-flight encryption
	- 클라이언트와 데이터베이스 간의 전송중 데이터 암호화
	- 클라이언트는 aws에서 제공하는 TLS 루트 인증서를 사용해야한다
- iam authentication
	- rds와 오로라이므로 사용자 이름과 패스워드라는 전통적인 조합을 사용할 수도 있다
	- aws이기도 하므로 iam역할을 사용해서 데이터베이스에 접속할 수도 있다
- security group
	- 보안 그룹을 사용해서 데이터베이스에 대한 네트워크 액세스를 통제할 수도 있다
	- 특정 포트, ip, 보안 그룹을 허용하거나 차단할 수 있다
- RDS와 오로라에는 SSH액세스가 없다
	- 다만 aws의 rds커스텀 서비스를 사용한다면 예외이다
- 감사로그 : 시간에 따라 rds및 오로라에서 어떤 쿼리가 생성되는지를 확인하려면 감사로그를 활성화 시키면 된다
	- 장기간 보관하고싶다면 cloudWatch Log에 전송해야한다


---

## Amazon RDS Proxy

VPC 내에 RDS 데이터베이스를 배포할 수 있다
완전 관리형 RDS 데이터베이스 프록시도 배포할 수 있다

Amazon RDS 프록시를 사용하면 애플리케이션이 데이터베이스 내에서 데이터베이스 연결 풀을 형성하고 공유할 수 있다

애플리케이션을 RDS 데이터베이스 인스턴스에 일일이 연결하는 대신 프록시가 하나의 풀에 연결을 모아 RDS 데이터베이스 인스턴스로 가는 연결이 줄어든다
왜?
- RDS데이터베이스 인스턴스에 연결이 많은 경우 CPU와 RAM등 데이터베이스 리소스의 부담을 줄여 데이터베이스 효율성을 향상 시킬 수있다. 데이터베이스에 개방된 연결과 시간초과를 최소화할 수 있기 때문이다 (시험에 나온다)

RDS프록시는 완전한 서버리스로 오토스케일링이 가능해 용량을 관리할 필요가 없고 가용성이 높다
다중 AZ지원
RDS에 장애조치가 발생하면 기본 인스턴스가 아니라 대기 인스턴스로 실행되며 RDS프록시 덕분에 RDS와 오로라의 장애 조치 시간을 66%까지 줄일 수 있다
	- 메인 RDS 데이터베이스 인스턴스에 애플리케이션을 모두 연결하고 장애 조치를 각자 처리하게 하는 대신 장애 조치와 무관한 RDS 프록시를 연결한다
	- RDS프록시가 장애 조치가 발생한 RDS 데이터베이스 인스턴스를 처리하므로 장애 조치 시간이 개선된다

프록시는 Mysql, PostgreSql, MariaDB용 RDS지원
Mysql, PostgreSQL용 오로라를 지원

데이터베이스에 IAM인증을 강제함으로써
IAM인증을 통해서만 RDS 데이터베이스 인스턴스에 연결하도록할 수 있다
자격증명은 AWS Secrets Manager 서비스에 안전하게 저장된다

데이터베이스에 IAM인증을 강제하고싶다면 프록시를 사용해라

RDS는 퍼블릭 액세스가 절대로 불가능하다
VPC내에서만 액세스할 수 있다. 인터넷을 통해 RDS프록시에 연결할 수 없으니 보안이 훌륭하다

람다 함수와 RDS프록시를 함께 사용하면 좋다
- 증식하는 람다가 RDS연결하게되면 개판날거다
- 개방된 연결에 시간초과도 발생하니 문제가 생긴다
- RDS프록시를 사용해서 해결할 수 있따
- 람다 함수의 연결 풀을 생성하면 람다 함수가 rds프록시를 오버로드한다
- rds프록시가 풀을 생성하면 rds 데이터베이스 인스턴스 연결이 줄어 문제를 해결할 수 있다


엑셀도 파이썬으로 진행하는게 좋을까?
db무는코드나 여타 다른코드는?
람다를 활용하면 카프카 필요없잖슴?
오케스트라 람다 필요함? 단일로 진행해도 될듯?
빠르면 좋잖슴? 그럼 마스터노드랑 서브노드로 구성해서 병합하는 방향도 좋을듯?

---

## Amazon ElastiCache

RDS가 관계형 데이터베이스를 관리하는 것과 같은 방식이다

엘라스틱 캐시는 캐싱 기술인 redis 또는 Memcached를 관리할 수 있도록 도와준다

>캐시란?
>캐시는 매우 높은 성능과 짧은 지연시간을 가진 인메모리 데이터베이스

캐시는 읽기 집약적인 워크로드에서 데이터베이스의 로드를 줄여준다

일반적인 쿼리는 캐시에 저장되므로, 매번 데이터베이스를 쿼리하지 않아도 된다

캐시만 사용하여 쿼리의 결과를 검색할 수 있다

애플리케이션의 상태를 엘라스틱캐시에 저장해서 애플리케이션을 상태 비저장형으로 할 수 있게 도와준다

RDS와 동일한 이점이 있기 때문에, aws는 데이터베이스의 운영 체제를 유지 관리할 수 있다

패치, 최적화, 설정, 구성, 모니터링, 장애복구, 백업 등

엘라스틱캐시를 사용하는 경우 애플리케이션의 코드를 많이 바꿔야한다
그냥 캐시를 껐다 켰다 하면 되는 게 아니다

캐시를 쿼리하도록 애플리케이션을 변경해야 한다. 데이터베이스를 쿼리하기 전이나 후에

### 엘라스틱 캐시를 사용하기 위한 아키텍처

애플리케이션은 일단 앨라스틱 캐시로 요청을 한다. 이미 실행된 쿼리라면 캐시 히트라고한다. 캐시히트가 됐다면 앨라스틱 캐시에서 바로 답을 준다. db로 이동하는 시간 절약. 캐시 미스가 발생하면 db로 요청을 보내서 읽는다.
다른 애플리케이션이나 다른 인스턴스에서 같은 쿼리가 발생하면 데이터를 캐시에 다시 쓸 수 있다.  

캐시 무효화 전략이 있어야한다
가장 최신 데이터만 사용되어야 하기떄문

또다른 아키텍처로는
세션을 저장한다
애플리케이션을 상태 비저장으로 만들기 위해
즉, 사용자가 어떤 애플리케이션에 로그인하면, 애플리케이션이 세션 데이터를 앨라스틱케시에 쓴다
사용자가 애플리케이션의 다른 인스턴스로 리디렉션되면, 애플리케이션은 그 세션의 세션 캐시를 앨라스틱 캐시에서 직접 검색할 수 있으므로, 사용자는 여전히 로그인 상태이다

### Redis vs Membcached

redis
자동 장애 조치기능이 있는 다중 az가 있다.
읽기 복제본이 있다
rds와 매우 유사
AOF 지속성을 이용한 데이터 내구성이 있다.
백업 및 복원 기능이 있다
> AOF(Append On File) 방식은 redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태이다.

캐시로서, set 및 정렬된set를 지원한다

redis는 복제되는 캐시라고 생각하면 된다. 가용성과 내구성이 뛰어나다 


memCached
멀티노드 사용 (데이터 샤딩)
고가용성이 없고 복제가 일어나지 않으며 영구 캐시가 아니다
백업 및 복원도 없다
멀티스레드 아키텍처이다
memcached에서는 여러 인스턴스가 모두 샤딩을 통해 작동된다
memcached는 분산되어있는 순수한 캐시이다. 데이터가 손실되어도 괜찮은 경우 사용

---

## ElasticCache Security

앨라스틱 캐시는 redis에서만 iam인증을 지원하며, 나머지 경우에는 사용자 이름과 비밀번호를 사용하면 된다

앨라스틱 캐시에서 iam정책을 정의하면 aws api 수준 보안에만 사용된다

redis auth라는 redis내 보안을 통해 비밀번호와 토큰을 설정할 수 있다 (redis 클러스터를 만들때)

또한 SSL 전송 중 암호화도 지원한다

memcached는 SASL 기반 승인을 제공한다
상당히 고급 메커니즘이다 (이름만 기억하면 된다)


앨라스틱 캐시에 데이터를 로드하는 패턴에는 세가지 종류가 있다
- Lazy Loading
	- 지연로딩
	- 모든 데이터가 캐시되고 데이터가 캐시에서 지체될 수있다
- Write Through
	- 데이터베이스에 데이터가 기록될 때마다 캐시에 데이터를 추가하더나 업데이트한다
	- 데이터가 지체되지 않는다
- Session Store
	-  유지 시간 기능을 사용해서 세션을 만료할 수 있다


지연 로딩 전략
애플리케이션 히트가 있는 경우, 앨라스틱 캐시에서 데이터를 가져온다 캐시 미스의 경우 데이터베이스에서 읽고 캐시에 쓰게된다
지연로딩이라고 불리는 이유는 캐시 히트가 없는 경우에만 데이터를 앨라스틱케시에 로드하기 때문이다


사용 사례
- 게이밍 리더보드 만들기
- 순위 정하기에 사용
- redis에는 정렬된 세트라는게 존재
- 고유성과 요소 순서를 모두 보장한다
- 요소가 추가될때마다 실시간으로 순서를 매긴다음 올바른 순서로 추가한다
- redis 클러스터가 있는 경우 실시간 리더보드를 만들 수 있다
- 모든 redis캐시는 동일한 리더보드를 사용할 수 있다
- 즉, 클라이언트가 redis를 사용하여 앨라스틱캐시와 대화할 때 이 실시간 리더보드에 액세스할 수 있으며, 애플리케이션 측에서 이 기능을 프로그래밍할 필요가 없다
- 정렬된 세트와 함께 redis를 활용하여 실시간 리더보드에 액세스할 수 있다
시험에 나올 수 있음


---
```
**중요한 포트:**

- FTP: 21
    
- SSH: 22
    
- SFTP: 22 (SSH와 같음)
    
- HTTP: 80
    
- HTTPS: 443
    

**vs RDS 데이터베이스 포트:**

- PostgreSQL: 5432
    
- MySQL: 3306
    
- Oracle RDS: 1521
    
- MSSQL Server: 1433
    
- MariaDB: 3306 (MySQL과 같음)
    
- Aurora: 5432 (PostgreSQL와 호환될 경우) 또는 3306 (MySQL과 호환될 경우)
```
