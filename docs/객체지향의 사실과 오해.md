---
layout: default
title: 객체지향의 사실과 오해
nav_order: "2"
---
# 객체지향의 사실과 오해
---

객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다.

실세계의 모방이라는 개념이 비현실적임에도 여전히 많은 사람들이 실세계 객체와 소프트웨어 객체 간의 대응이라는 과거의 유산을 반복적으로 재생산하는 이유는 뭘까?

그것은 실세계에 대한 비유가 객체지향의 다양한 측면을 이해하고 학습하는 데 매우 효과적이기 때문이다.

## 협력하는 객체들의 공동체

카페에서 내손에 커피가 들어오기 까지는
주문하는 손님(나), 주문을 받는 캐시어, 커피를 제조하는 바리스타의 `역할`이 존재한다.

손님, 캐시어, 바리스타는 손님에게 커피를 제공하기 위해 `협력`하는 과정에서 맡은 바 `책임`을 다한다.

![[Pasted image 20240430224817.png|400]]

특정 역할을 맡은 사람은 그에 대한 책임을 갖는다. 바리스타라는 역할은 커피를 제조해야 할 책임을 가지고 있다.

역할과 책임은 협력이 원활하게 진행되는 데 필요한 핵심적인 구성 요소이다.

사람들이 협력을 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행한다는 사실은 몇가지 중요한 개념을 제시한다.

- 여러 사람이 동일한 역할을 수행할 수 있다.
	- 커피를 마실 수 있다면, 어떤 캐시어가 주문을 받는지 중요하지 않다.
- 역할은 대체 가능성을 의미한다
	- 원하는 일처리만 해준다면 그 역할을 맡은 사람이 누구인지는 중요하지 않다.
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다.
- 한 사람이 동시에 여러 역할을 수행할 수 있다.

목표를 달성하기 위해 목표는 더 작은 책임으로 분할되고 책임을 수행할 수 있는 적절한 역할을 가진 사람에 의해 수행된다.

협력에 참여하는 각 개인은 책임을 수행하기 위해 다른 사람에게 도움을 요청하기도 하며, 이를 통해 연쇄적인 요청과 응답으로 구성되는 협력 관계가 완성된다.

객체지향 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작된다.

협력 공동체의 일원으로서 객체는 두가지 덕목을 갖춰야 한다.
1. 객체는 충분히 협력적이어야 한다. 객체는 다른 객체의 요청에 충실히 귀 기울이고 다른 객체에게 적극적으로 도움을 요청할 정도로 열린 마음을 지녀야 한다. (전지전능한 객체는 복잡도에 의해 자멸해버린다)
2. 객체는 충분히 자율적 이여야 한다. 자율적이라는 뜻은 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는것 이라는 뜻이다.

객체가 협력하는 과정에서 스스로 판단하고 결정하는 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지녀야한다.

객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 외부와는 허락된 수단만을 동해서 소통해야한다.


### 객체지향의 본질
- 자율적인 객체들의 공동체
- 상태와 행위를 지니며 자기자신을 책임지는 객체를 의미
- 다른 객체와 협력하며, 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다

## 이상한 나라의 객체

이상한 나라의 엘리스는 시간의 지남에 따라 자신의 키가 변화되는데, 이는 자신이 어떤 행동을 하느냐에 따라 키(상태)가 결정된다. 또한 자신의 키(상태)에 따라 다음 행동이 결정된다.

이처럼 객체는 다음과 같은 특징을 갖는다
- 객체는 상태를 가지며 상태는 변경 가능하다
- 상태를 변경시키는 것은 행동이다
	- 행동은 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
	- 행동의 순서가 결과에 영향을 미친다
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다

하나의 개별적인 실체로 식별 가능한 물리적인 또는 개념적인 사물은 어떤 것이라도 객체가 될 수 있다. 인간의 인지 능력 안에서 개수를 셀 수 있고, 다른 사물과 구분할 수 있으며, 생성 시점을 알 수 있고, 독립적인 하나의 단위로 인식할 수 있는 모든 사물은 객체이다.

**객체를 상태, 행동, 식별자를 지닌 실체로 보는것이 가장 효과적이다**

상태가 왜 중요한가?
상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 상식을 이해할 수 있다.
(객체의 상태를 구성하는 모든 특징을 통틀어 프로퍼티 라고한다. 가령 엘리스의 키, 위치 등)
![[Pasted image 20240430233048.png|400]]

행동은?
객체가 협력에 참여할 수 있는 유일한 방법이다.
객체의 행동은 두가지 관점의 부수 효과를 명확하게 서술해야 한다.
- 객체 자신의 상태 변경
- 행동 내에서 협력하는 다른 객체에 대한 메시지 전송

상태의 캡슐화
![[Pasted image 20240430234013.png|400]]
엘리스는 drinkBeverage()메시지를 전달받고 음료에게 전달하는 메시지는 drunken(quantity)이다. 두 메시지를 보고 엘리스의 키가 크거나 음료의 양이 줄어듦을 예상할 수 있는가?
이처럼 송신자는 수신자의 상태를 전혀 알지 못하는것이 캡슐화이다.

객체의 상태를 변경할지 여부는 객체 스스로 결정한다. 메시지 송신자는 단지 자신의 요구를 메시지로 포장해서 전달 할 뿐이다.

메시지를 해석하고 그에 반응해서 상태를 변경할지 여부는 전적으로 메시지 수신자의 자율적 판단에 따른다. 송신자가 상태 변경을 기대하더라도 수신자가 자신의 상태를 변경하지 않는다면 송신자가 간섭할 수 있는 어떤 여지도 없다.

상태의 캡슐화는 결과적으로 객체의 자율성을 높인다. 자율적인 객체는 스스로 판단하고 스스로 결정하기 때문에 객체의 지능도 높아진다. 객체의 지능이 높아질수록 협력은 유연하고 간결해진다.

식별자
인간의 인지 능력을 이용해 식별 가능한 경계를 가진 모든 사물을 의미한다.

값과 객체의 차이는 값은 식별자가 없지만 객체는 식별자가 있다는 것이다.
시스템 설계할 때는 이런 단순한 값과 객체의 차이점을 명확하게 구분하고 명시적으로 표현하는 것이 매우 중요하다.

값은 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다.

### 기계로서의 객체
일반적으로 객체의 상태를 조회하는 작업을 쿼리라고 하고 객체의 상태를 변경하는 작업을 명령이라고 한다.
![[Pasted image 20240430235407.png|400]]
기계로서의 엘리스

엘리스는
- 음료를 마시다
- 케이크를 먹다
- 부채질하다
- 버섯을 먹다
- 문을 통과하다
와 같은 5개의 행동이 있다.
그리고 키와 위치라는 상태를 가진다

앞 4개의 네모난 버튼을 통해 키를 변경시킬 수 있으며, 마지막 네모 버튼으로 위치를 변경시킬 수 있다.

동그란 두 버튼으로 키와 위치를 확인할 수 있다.

사용자가 객체 기계의 버튼을 눌러 상태를 변경하거나 상태를 조회를 요청하는 것은 객체의 행동을 유발하기 위해 메시지를 전송하는 것과 유사하다.

### 행동이 상태를 결정한다
객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다.

애플리케이션 안에 살아갈 앨리스 객체를 설계할 때 초보자들은 앨리스 객체에게 필요한 상태가 무엇인지 찾고 키와 위치를 앨리스에 추가한다. 그리고 나서야 키와 위치를 변경하거나 조회할 수 있는 행동이 무엇인지를 고민한다.

안타깝게도 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다
2. 협력에 적합하지 못한 객체를 창조하게 된다.
3. 객체의 재사용성이 저하된다. 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하된다.

결국 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야한다. (RDD)

### 두번째 도시 전설 현실세계의 모방
모방과 추상화라는 개념만으로는 현실 객체와 소프트웨어 객체 사이의 관계를 깔끔하게 설명하지 못한다.

#### 의인화
그렇다면 현실속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 뭘까?
그것은 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것이다.

소프트웨어 객체를 창조할 때 우리는 결코 현실 세계의 객체를 모방하지 않는다. 오히려 소프트웨어 안에 창조하는 객체에게 현실 세계의 객체와는 전혀 다른 특징을 부여하는것이 일반적이다.

음료는 스스로 줄어들 수 없으며, 계좌는 스스로 금액을 이체할 수 없다.

레베카 워프스브록은 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 **의인화**라고 부른다

소프트웨어 안에 구축되는 객체지향 세계는 현실을 모방한 것이 아니다. 조금 참조 할 뿐이다.

이상한 나라를 창조하라...

## 타입과 추상화

![[Pasted image 20240501012854.png|400]]
![[Pasted image 20240501012909.png|400]]
해리 벡은 승객이 꼭 알아야 하는 사실만 정확하게 표현하고 몰라도 되는 정보는 무시함으로써 이해하기 쉽고 단순하며 목적에 부합하는 지하철 노선도를 창조해 낼 수 있었다.
해리 벡의 가장 위대한 업적은 지하철 노선을 추상화한 것이다.

훌륭한 추상화는 목적에 부합하는 것이어야 한다.
```
추상화
어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생량하거나 감춤으로써 복잡도를 극복하는 방법이다.

- 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하자
```

#### 개념
![[Pasted image 20240501014326.png|400]]
앨리스는 정원의 인물들을 트럼프와 토끼라는 두개의 그룹으로 나누어 표현했다. 인물들의 차이점을 의도적으로 무시하고 공통점만을 강조 함으로써 트럼프라는 그룹에 속할 수 있는 인물들을 취사 선택한 것이다.

이처럼 공통점을 기반으로 객체들을 묶기 위한 그릇을 개념이라고한다. 개념이란 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 뜻한다.

우리는 개념을 적용하는데 익숙하다. 길 거리를 빠른 속도로 누비는 교통수단에 대해서는 자동차 라는 개념을 적용한다.

개념을 이용하면 객체를 여러 그룹으로 **분류** 할 수 있다. 결과적으로 개념은 공통점을 기반으로 객체를 분류할 수 있는 일종의 체라고 할 수 있다.

이처럼 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될때 객체를 그 개념의 **인스턴스**라고한다.

#### 개념의 세가지 관점
-  심볼 : 개념을 가리키는 간략한 이름이나 명칭
	- 트럼프
-  내연 : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
	- 몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려있다는 설명
-  외연 : 개념에 속하는 모든 객체의 집합
	- 인스턴스들이 모여 이뤄진 집합을 가르킴 (하트 잭, 하트 왕, 하트 여왕 등등)


**분류는 객체 지향의 가장 중요한 개념 중 하나다. 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.**

#### 타입
![[Pasted image 20240501020115.png|400]]
트럼프 인간은 트럼프보다 좀 더 특화된 행동을 하는 특수한 개념이다. 이 두 개념 사이의 관계를 일반화/특수화 관계라고 한다.

#### 일반화/특수화 관계
중요한 것은 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이라는 것이다.

두 타입 간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 한다.

일반적인 타입이랑 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입을 가리킨다.


#### 슈퍼타입과 서브타입
일반적인 타입을 **슈퍼타입**이라고하고 좀 더 특수한 타입을 **서브타입**이라고 한다.
다시한번 강조하지만 중요한 것은 두 타입 간의 관계가 행동에 의해 결정된다는 점이다.
![[Pasted image 20240501020649.png|400]]

#### 클래스
클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘중 하나이다.
클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 클래스와 타입을 동일시하는 것은 오해와 혼란을 불러일으키곤 한다.

객체지향에서 중요한 것은 동적으로 변하는 객체의 상태와 상태를 변경하는 행위다. 클래스는 그것을 구현하는 메커니즘이라는 사실을 기억하자.

## 역할, 책임, 협력

책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할도는 것이 일반적이다.

역할은 책임의 집합을 의미한다.
![[Pasted image 20240501171517.png|400]]
위의 세 과정은 너무나도 유사해서 하나의 협력으로 다루고 싶다. 방법은 간단하다. 재판이라는 협력 과정 속에서 하트 왕과 하트 여왕은 '판사'의 역할을 한다. 모자 장수와 요리사, 앨리스는 '증인'의 역할을 수행한다. 따라서 '판사'와 '증인'이라는 역할을 사용하면 세가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.

![[Pasted image 20240501171731.png|400]]
역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것이다. 

역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자다. 따라서 본질적으로 역할은 다른 객체에 의해 대체 가능함을 의미한다.

객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목하라. 판사의 역할을 수행할 수 있는 왕은 재판을 할 책임뿐만 아니라 국정을 돌봐야할 추가적인 책임을 가지고 있다.

결국 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. 따라서 대부분의 경우에 객체의 타입과 역할 사이에는 일반화/특수화 관계가 성립하는 것이 일반적이다.

#### 흔한 오류
많은 사람들은 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다는 선입견을 가지고 있다. 물론 객체가 상태의 일부로 데이터를 포함하는 것은 사실이지만 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일 뿐이다.

두번째 선입견은 객체 지향의 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 것이다. 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체이다. 객체 지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이다.


## 책임과 메시지
객체지향을 강력하게 만드는 비밀은 책임과 메시지에 숨겨져있다.

역할과 책임이 흐릿 할수록 문제를 해결하려는 객체를 도와줄 어떤 협력자도 찾지 못할것이다.

자율적인 책임의 특징은 객체가 어떻게 해야하는가가 아니라 무엇을 해야하는가를 설명한다는 것이다.

메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 인자를 통해 추가 정보를 제공할 수 있다.
예를 들어, 왕이 모자 장수에게 증언하라라고 요청할 때 부가적으로 특정한 장소와 시간에 목격한 것을 증언하라고 요청할 수도 있다.

`모자장수.증언하라(어제, 왕국)`

모자장수가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드라고 한다.

메시지와 메서드의 차이 관계를 이해하고 나면 객체지향의 핵심 개념인 다형성을 쉽게 이해할 수 있다. 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.

#### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미
왕의 증언하라 라는 메시지를 전송할 수  있지만 수신자의 구체적인 타입에 대해서는 알지 못한다. 따라서 왕은 수신자가 메시지를 수신할 수만 있다면 누가 되더라도 상관하지 않는다. 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.

- 협력이 유연해진다
- 협력이 수행되는 방식을 확장할 수 있다.
- 협력이 수행되는 방식을 재사용할 수 있다.

#### 객체 인터페이스
일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다. 사람들은 말과 글이라는 인터페이스를 이용해 자신의 의사를 전달한다.

일반적으로 인터페이스는 3가지 특징을 가진다.
1. 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만들 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
3. 대상이 변경되더라도 동일한 인터페이스만 제공하면 아무런 문제 없다

#### 메시지가 인터페이스를 결정한다.
객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이다. 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성된다.

인터페이스와 구현의 분리
맷 와이스펠드는 다음 3가지를 중요하다고 주장한다
- 좀 더 추상적인 인터페이스
- 최소 인터페이스
- 인터페이스와 구현 간에 차이가 있다는 점을 인식

증언 하라와 같은 요청과 달리 목격했던 장면을 떠올려라, 떠오르는 기억을 시간 순서대로 재구성해라, 말로 간결하게 표현하라 와 같은 지나치게 상세한 수준의 메시지를 보내는 것은 객체의 자율성을 저해한다.

두번째 최소 인터페이스 원칙은 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말라는 것이다. 따라서 객체의 내부를 수정하더라도 외부에 미치는 영향을 최소화 할 수 있다.

객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현이다.
객체는 상태를 가진다. 상태를 어떻게 표현할 것인가는 객체의 구현에 해당한다.
객체는 행동을 가진다. 행동은 메시지를 수신했을 때만 실행되는 일종의 메시지 처리 방법이다.

인터페이스와 구현의 분리 원칙이 왜 중요할까? 그것은 소프트웨어는 항상 변경되기 때문이다. 수정했을때 어떤 객체가 영향받는지 판단하는 것은 거의 곡예에 가깝다.

#### 책임의 자율성이 협력의 품질을 결정한다
1. 자율적인 책임은 협력을 단순하게 만든다
2. 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다
3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다
4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연석을 제공한다.
5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.

## 객체 지도
사람들의 요구사항은 계속 변하기 때문에 모델이 제공해야 하는 기능 역시 이에 따라 지속적으로 변할 수밖에 없다. 따라서 기능을 중심으로 구조를 종속시키는 접근법은 범용적이지 않고 재사용이 불가능하며 변경에 취약한 모델을 낳게 된다.

자주 변경되는 기능이 아니라 안정적인 구조를 따라 역할, 책임, 협력을 구성하라. 이것이 이번 장의 주제이다.

미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다. 단지 언제가는 변경이 발생할 것이며 아직까지는 그것이 무엇인지 모른다는 사실을 겸허하게 받아들인다. 좋은 설게는 변경의 여지를 남겨놓는 설계이며, 소요되는 비용을 낮추는 것이다.

변경의 여지를 남겨놓는 가장 좋은 방법은 자주 변경되는 기능이 아닌 안정적인 구조를 중심으로 설계하는 것이다.시스템의 기능은 더 작은 책임으로 분할되고 적절한 객체에게 분배되기 때문에 기능이 변경되더라도 객체 간의 구조는 그대로 유지된다.

![[Pasted image 20240501183112.png|400]]

객체지향 세계를 구축하기 위해서는 사용자에게 제공할 기능과 기능을 담을 안정적인 구조라는 재료가 필요하다.
- 구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
- 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위 

일반적으로 기능을 수집하고 표현하기 위한 기법을 유스케이스 모델링
구조를 수집하고 표현하기 위한 기법을 도메인 모델링이라고 한다.

#### 안정적인 재료 : 구조
도메인 모델
소프트웨어를 사용하는 사람들은 자신이 관심을 가지고 있는 특정한 분야의 문제를 해결하기 위해 소프트웨어를 사용한다. 이처럼 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다.

도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.

은행 업무에 종사하는 사람들은 은행 도메인을고객과 계좌 사이의 돈의 흐름으로 이해 할 것이다.
중고 자동차 판매상은 구매되는 자동차와 판매되는 자동차의 교환으로 자동차 도메인을 바라볼 것이다.

코드의 구조가 도메인의 구조를 반영하기 때문에 도메인을 이해하면 코드를 이해하기가 훨씬 수월해진다. 도메인 속의 개념과 관계가 코드 속에 녹아 있기 때문에 도메인이 알려주는 길을 따라가면 코드 속에서 길을 잃지 않을 수 있다. 결국 도메인 모델은 코드 안에 존재하는 미로를 헤쳐나갈 수 있는 지도를 제공한다.

도메인 모델을 기반으로 코드를 작성하는 두 번쨰 이유는 도메인 모델이 제공하는 구조가 상대적으로 안정적이기 때문이다.

소프트웨어 개발의 가장 큰 적은 변경이며 변경은 항상 발생한다는 사실을 기억하자. 사용자 모델에 포함된 개념과 규칙은 비교적 변경될 확률이 적기 때문에 사용자 모델을 기반으로 설계와 코드를 만들면 변경에 쉽게 대처할 수 있을 가능성이 커진다.


#### 불안정한 재료 : 기능
유스케이스
기능적 요구사항이란 시스템이 사용ㅈ자에게 제공해야하는 기능의 목록을 정리한 것이다.
사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라고 한다.

- 유스케이스는 다이어그램이 아니다. 중요한 것은 유스케이스 안에 포함돼 있는 상호작용의 흐름이다.
- 유스케이스는 하나의 시나리오가 아니라 여러 시나리오의 집합이다.
- 유스케이스는 단순한 피처 목록과 다르다.
	- 피처는 시스템이 수행해야하는 기능의 목록을 단순하게 나열한 것이다. 피처의 단점은 연관성이 있는 두 피처를 독립적인 기능으로 보이게끔 만든다는 점이다.
- 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.
	- 유스케이스에는 사용자가 해지 일자를 선택하기 위해 사용자 인터페이스를 어떻게 구성해야하는지에 대한 정보가 전혀 포함돼 있지 않다.
	- 자주 변경되는 사용자 인터페이스 요소는 베제하고 행위에 초점을 맞춘다
- 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다

#### 재료 합치기 : 기능과 구조의 통합
![[Pasted image 20240501230704.png|400]]

> 왜 이자를 계산하는 책임을 이자율 객체에게 할당하는가?
> 책임 할당의 기본 원칙은 책임을 수행하는 데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것이다.

시스템에 할당된 커다란 책임은 이제 시스템 안의 작은 규모의 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화 된다.

그렇다면 어떤 객체를 선택할 것인가? 이 시점에 도메인 모델이 등장한다. 우리는 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택해야 한다.

협력을 완성하는 데 필요한 메시지를 식별하면서 객체들에게 책임을 할당해 나간다.

마지막으로 협력에 참여하는 객체를 구현하기 위해 클래스를 추가하고 속성과 함께 메서드를 구현하면 시스템의 기능이 완성된 것이다.


## 추상화 기법

추상화 기법의 종류
![[Pasted image 20240501231743.png|400]]

