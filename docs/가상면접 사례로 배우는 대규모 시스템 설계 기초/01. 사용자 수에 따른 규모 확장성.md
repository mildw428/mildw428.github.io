---
layout: default
title: 01. 사용자 수에 따른 규모 확장성
parent: 가상면접 사례로 배우는 대규모 시스템 설계 기초
---
# 01. 사용자 수에 따른 규모 확장성
---

## 로드 벨런서
로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.
![[Pasted image 20240802003341.png]]

## 캐시
캐시 사용시 유의할 점
어떤 상황에 바람직한가?
어떤 데이터를 캐시에 두어야하는가?
캐시에 보관된 데이터는 어떻게 만료 되는가?
일관성은 어떻게 유지되는가?

장애는 어떻게 대처할 것인가?
캐시 서버를 한대만 두는 경우 해당 서버는 단일 장애 지점(Single Point Of Failure)이 되어버릴 가능성이 있다. 단일 장애 지점이란 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우를 일컫는다.
SOPF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.

캐시 메모리는 얼마나 크게 잡을 것인가?

데이터 방출 정책은 무엇인가?
캐시가 꽉 차버리면 추가로 캐시에 데이터를 넣어야 할 경우 기존 데이터를 내보내야 한다. 가장 널리 쓰이는 것은 LRU이다.

## 콘텐츠 전송 네트워크 CDN

사용시 고려사항
비용 : 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않으므로, CDN에서 빼는것을 고려하도록 하자.

만료 시한 : 시의성이 중요한 콘텐츠의 경우 만료 시점을 잘 정해야 한다. 너무 길지도 않고 짧지도 않아야 한다. 너무 길면 콘텐츠의 신선도는 떨어지고, 너무 짧으면 서버에 빈번히 접속하게 되어 좋지 않다.

CDN 장애에 대한 대처 방안: CDN 자체가 죽었을 경우 웹사이트 / 애플리케이션이 어떻게 동작해야 하는지 고려해야 한다. CDN이 응답하지 않을경우 문제를 감지하여 원본 서버로부터 직접 콘텐츠를 가져오도록 클라이언트를 구성하는 것이 필요할 수도 있다.



## 무상태 웹 계층
상태 정보 의존적인 아키텍처
![[Pasted image 20240802000434.png]]
사용자 A의 세션 정보나 프로파일 이미지 같은 상태 정보는 서버1에 저장된다. 사용자 A를 인증하기 위해 HTTP 요청은 반드시 서버1로 전송되어야 한다. 요청이 서버 2로 전송되면 인증은 실패할 것인데, 서버2에 사용자A에 관한 데이터는 보관되어 있지 않기 때문이다.

문제는 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다. 대부분의 로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하고 있는데, 이는 로드밸런서에 부담을 준다.

무상태 아키텍처
![[Pasted image 20240802000720.png]]


## 메시지 큐
메세지 큐는 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트다. 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.

![[Pasted image 20240802000942.png]]

메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느스해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.
작업이 오래걸릴 수 있는 프로세스는 비동기적으로 처리하면 편리하다.



## 로그, 메트릭 그리고 자동화
소규모 웹 사이트를 만들 때는 로그나 메트릭, 자동화 같은 것은 하면 좋지만 꼭 할 필요는 없었다. 하지만 웹 사이트와 함께 규모가 커지고 나면, 그런 도구에 필수적으로 투자해야한다.

메트릭 가운데 특히 유용한 것을 몇가지 살펴보면
호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O
종합 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능
핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문

자동화 : 빌드, 테스트, 배포 등의 절차를 자동화 하여 개발 생산성을 크게 향상시킬 수 있다.



## 데이터베이스의 규모 확장

스택오버플로는 2013년 한 해 동안 방문한 천만 명의 사용자 전부를 단 한대의 마스터 데이터베이스로 처리하였다. 하지만 이런 스케일업에는 몇 가지 심각한 약점이 있다.

- 성능을 무한으로 증설할 수 없으니 결국 감당하기 어려워진다.
- Single Point Of Failure로 인한 위험성이 크다.
- 비용이 많이 든다. 성능이 좋을수록 가격이 올라가기 마련이다.

### 샤딩
샤딩은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫는다. 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

![[Pasted image 20240802002421.png]]
![[Pasted image 20240802002429.png]]
이 사례는 user_id % 4를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정한다.

샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 샤딩 키를 어떻게 정하느냐 하는 것이다. ('파티션 키'라고도 부름)

샤딩은 훌륭한 기술이지만 완벽하지 않다.
샤딩을 도입하면 시스템이 복잡해지고 풀어야 할 새로운 문제도 생긴다.

데이터의 재 샤딩
재 샤딩은 다음과 같은 경우에 필요하다.
1. 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
2. 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때
3. 핫스팟 키 문제라고도 불리는 문제로, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
4. 조인과 비정규화 문제 : 일단 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 이를 해결하는 한 가지 방법은 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.



시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이다.
이번 장의 내용을 정리해보면 다음과 같다
- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분리할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
