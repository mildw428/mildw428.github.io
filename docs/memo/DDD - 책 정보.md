---
layout: default
title: DDD - 책 정보
parent: memo
---
# DDD - 책 정보
---

Doamin Driven Design : 도메인 주도 설계

## 도메인 주도 개발 시작하기 (저자 : 최범균)

### chepter1. 도메인 모델 시작하기

#### 도메인이란?

온라인 서점에서 우리는
- 어떤 책이 나왔는지 검색
- 목차와 서평 조회
- 장바구니 담아두기
- 바로 구매
- 쿠폰 확인
- 간편 결제
- 외부 포인트 사용
- 배송 추적
등등의 기능을 사용한다.
이처럼 온라인 서점은 책을 판매하는데 필요한 상품 조회, 구매, 결제, 배송 추적 등의 기능을 제공해야 한다.
이때 온라인 서점은 소프트웨어로 해결하고자 하는 문제 영역, 즉 도메인에 해당한다.

![[Pasted image 20230102190039.png|400]]
도메인은 여러 하위 도메인으로 구성된다.
한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공한다.
고객이 물건을 구매하면 주문, 결제, 배송, 혜택 하위 도메인의 기능이 엮이게 된다.


#### 도메인 전문가와 개발자 간 지식 공유

서비스를 사용하는 각 분야의 전문가들은 개발자에게 다양한 기능을 요구할 수 있다.
당연하지만 요구사항을 이해하는것은 중요하며 ,요구사항을 올바르게 이해하지 못하면 엉뚱한 기능을 만들게 된다.

개발자와 전문가 사이에 내용을 전파하는 전달자가 많으면 많을수록 정보가 왜곡되고 손실이 발생한다.
이로인해 개발자는 최초로 요구했던 요구사항과 다른 개발을 하게된다. ← 지금은 기획리뷰를 다같이 들어가기 때문에 괜찮은 것 같다.

#### 도메인 모델

도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.

주문도메인 → 상품 선택 및 갯수 선택, 배송지 입력 → 결제 수단 선택 및 결제 → 주문 → 배송 추적 → 배송지 변경 또는 주문 취소
위와 같은 과정을 할 수 있는 도메인이라고 했을때
![[Pasted image 20230102191730.png|400]]
> 도메인 모델은 다양한 방법으로 표현될 수 있다. (상태 다이어그램, 그래프 등) 

위와 같은 도메인 모델을 만들 수 있다.
도메인 모델을 사용하면 여러 이해관계자들이 동일한 모습으로 도메인을 이해하고 지식을 공유하는데 도움이 된다.

#### 도메인 모델 패턴

일반적인 애플리케이션 아키텍처는 네 개의 영역으로 구성된다.
- 표현 - 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. (여기서 사용자는 외부 시스템이 될 수 있음)
- 응용 - 사용자가 요청한 기능을 실행한다. **업무 로직을 직접 구현하지 않으며** 도메인 계층을 조합해서 기능을 실행한다.
- 도메인 - 시스템이 제공할 도메인 규칙을 구현한다.
- 인프라스트럭처
- DB
>**인프라스트럭쳐 :** 구현기술에 대한 것을 다룬다. RDBMS 연동을 처리하고, 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현하고, 몽고 DB나 HBase를 사용해서 데이터 베이스 연동을 처리한다. 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.

도메인 계층은 핵심 규칙을 구현한다.

예를들면
- 출고 전에 배송지를 변경 할 수 있다.
- 주문 취소는 배송 전에만 할 수 있다.
와 같은 규칙들은 도메인 계층에 위치한다.

```java
public enum OrderState {
	PAYMENT_WATING {
		public boolean isShippingCahngeable() {
			return true;
		}
	}
	//... 다른 주문 상태값들
}
```

위와같이 주문 상태 enum 클래스에 변경 가능 여부를 판단해 주는 로직을 넣을 수 있다.

만약, 변경 가능 상태를 판단하는것이 OrderState만으로는 불가는하다면 Order 클래스에 구현한다.

>모델의 종류에는 개념모델과 구현모델이 있다.
>개념모델은 순수하게 문제만 분석한 결과물이다. 고로 transaction과 db와 같은 것들이 고려되어있지 않다.
>처음부터 완벽한 개념모델을 만들긴 어렵다. 윤곽만 잡고 구현모델로 점진적으로 발전 시켜나가야 한다.

#### 도메인 모델 도출

도메인 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는것이다.

- 최소 한 종류 이상의 상품을 주문해야 한다.
- 한 상품을 한 개 이상 주문할 수 있다.
- 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- ... 등등

이 요구사항에서 알 수 있는 것은
- 출고 상태로 변경하기
- 배송지 정보 변경하기
- 주문 취소하기
- 결제 완료하기
의 기능을 제공한다는 것이다.

```java
public class Order {
	public void changeShipped() {...}
	public void changeShippingInfo(ShippingInfo newShppingInfo) {...}
	public void cancel() {...}
	public void completePayment() {...}
}
```

기능을 찾으면 위와같이 함수를 뽑아 낼 수 있다.

다음으로 
- 한 상품을 한 개 이상 주문할 수 있다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
위의 조건을 통해 '주문 항목'이 관리 되어야하고, 이는 주문할 상품, 상품의 가격, 구매 개수를 포함해야 하는것을 도출 할 수 있다.
또한 상품의 주문 갯수와 가격의 총 값을 계산하는 함수를 만들어 관리할 수 있다.
```java
public class OrderLine {
	public Product product;
	public int price;
	public int quantity;
	public int amounts;

	public OrderLine(Product product, int price, int  quntity) {
		this.product = product;
		this.price = price;
		this.quantity = quantity;
		this.amounts = calculaterAmounts();
	}

	public int calculaterAmounts() {
		return price * quamtity;
	}
}
```

책의 이하 내용은 위와같은 내용이 반복된다.

#### 엔티티와 벨류

도출한 모델은 크게 '엔티티'와 '밸류'로 구분할 수 있다. 

엔티티와 벨류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있다.

엔티티는 식별자를 가지고있다.
~~시간 + UUID 조합 괜찮은거같은데?~~

밸류 타입의 예로는 ShppingInfo가 있다.
```java
public class ShppingInfo {
	private String receiverName;
	private String receiverPhone;
	private String shppingAddress1;
	private String shppingAddress2;
	private String shppingZipcode;
}
```

ShippingInfo의 name과 phone 필드는 서로다른 두 데이터를 담고 있지만 두 필드는 개념적으로 받는 사람을 의미한다.
~~처음에 왜 User테이블을 참조하지 않지? 라고 생각했지만, 한 User는 받는사람의 이름과 주소를 바꿀 수 있다는걸 깨달았다!~~~

밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다.
예를 들어 받는사람 receiverName과 receiverPhone은 Receiver 라는 밸류로 정의될 수 있으며,
shppingAddress1,shppingAddress2,shppingZipcode 는 Address라는 밸류로 정의 할 수 있다.

```java
public class ShppingInfo {
	private Receiver receiver;
	private Address address;
}
```
.
.
.
밸류타입은 꼭 두개 이상의 필드를 가져야 하는건 아니다.
주문에서의 amounts는 돈을 의미하는데, 이 때 Money라는 밸류를 만들어서 사용하면 코드를 이해하는데 도움이된다.
```java
public class Money {
	private int value;

	public Money(int value) {
		this.value = value;
	}
}
```

Money 밸류 클래스에 `add(Money money)` 또는 `multiplier(int multiplier)`와 같은 함수를 만들어서 사용 할 수 있다.
(예제는 간단하지만, 조건부가 추가되면 쓸만할듯 하다)

밸류를 사용할때 값의 변경을 위해서는 항상 새로운 밸류를 생성해서 교체 방식으로 진행한다.
`OrderLine line = new OrderLine(product, price, 2);`
이렇게 하지않고, setter를 허용하여 진행할 경우 `line.setPrice(2000)`
price 값이 잘못 반영되는 **참조 투명성과 관련된 문제**를 발생 할 수 있다.

>**참조 투명성**
>수학과 프로그래밍에서 모두 '함수'라는 말을 사용하고, 유사한 개념으로 사용됩니다. 하지만 둘의 결정적으로 다른 점이 있습니다.
>수학에서의 함수는 같은 입력값이면 계산 된 결과는 항상 같습니다.
>예를들어 f(x) = x*2 라는 함수가 있을 때, 같은 x 값을 넣게 되면 반환되는 f(x) 값은 항상 같습니다. 하지만 프로그래밍에서는 항상 같지 않습니다.
```
int count = 0;
int count(){
    return count++;
}
```
>위와 같은 함수 count의 경우 매번 반환되는 값이 다르게 됩니다.
```
final int x = 10;
int getX(){
    return x;
}
```
>반면 위와 같은 함수는 항상 같은 x의 값을 반환하게 됩니다. 이러한 경우를 '참조 투명'하다 라고 합니다. 앞서서 설명한 수학에서의 함수는 모두 참조 투명성을 갖고 있습니다. 그리고 이러한 함수를 참조 투명 함수 라고 부릅니다.

엔티티도 마찬가지로 생성자를 통해 진행하자.
완전한 도메인 객체를 생성함으로써 null 체크로부터 조금이나마 자유로워질 수 있다.

#### 도메인 용어와 유비쿼터스 언어

STEP1, STEP2, STEP3와 같이 알아볼 수 없는 변수명은 지양 하자 라는 내용 (지금 잘 지키고 있는듯 하다.)

---

### chepter2. 아키텍처 개요

#### 네 개의 영역

표현, 응용, 도메인, 인프라스트럭처

응용서비스 영역은 도메인 서비스 영역으로 모든 로직을 위임한다.
도메인 서비스에서는 핵심 로직을 구현하고, 응용서비스에서 이를 조합하여 사용한다.

마리아DB, SMTP서버, kafka 등 구현 기술을 사용한 코드는 인프라스트럭처 영역에서 다룬다.
도메인영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다.

예를들어 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라 스트럭처 영역의 DB모듈을 사용하여 데이터를 읽어온다.

#### 계층 구조 아키텍처

표현
↓
응용
↓
도메인
↓
인프라스트럭처

네 영역을 구성할 때 많이 사용하는 아키텍처가 위와 같은 계층 구조이다.
계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고
하위  계층은 상위 계층에 의존하지 않는다.

예를 들어, 표현 게층은 응용 계층에 의존하고 응용 계층이 도메인 계층에 의존하지만,
반대로 인프라스트럭처 계층이 도메인에 의존하거나 도메인이 응용 계층에 의존하지 않는다.

하지만, 편리를 위해 바로 하위 계층이아닌 더 아래 계층에 의존 할 수 있다.
(응용계층이 인프라스트럭처 계층에 의존하는 경우)
이러한경우 동작은 하겠지만 두가지 문제를 가지고 있다.
1. 해당 서비스만 테스트하기 어렵다. 테스트를 위해 의존하고 있는 인프라스트럭처가 정상동작 한다는 전제 조건이 깔리게된다.
2. 구현 방식을 변경하기 어려워진다. 인프라스트럭처의 변경에 따라 응용계층의 코드 다량으로 수정해야 할 수 있다.
이는 DIP로 해결 할 수 있다.

#### DIP

>의존성 역전 원칙

DIP는 저수준모듈(인프라스트럭처)를 고수준모듈(응용)에 의존하도록 바꾼다.
고수준 모듈을 구현하려면 저수준모듈이 필요할텐데 이를 어떻게 해결할까? 비밀은 추상화 인터페이스에 있다.

할인 기능을 예로 들면,
1. `public interface RuleDiscount` 라는 추상클래스를 만들고
2. `public class calculateDiscountServce` 라는 응용 계층은 `RuleDiscount` 를 사용하여 할인 함수를 구현한다.
3. `public class DroolsRuleDiscounter` 라는 인프라스트럭처 계층에
   `implemets RuleDiscounter` 를 통해 상속 받게 함으로써, 상위계층에 필요한 함수를 구현하게 만든다.

**주의 해야할 점은 DIP를 적용할때 고수준 모듈을 기준으로 인터페이스를 추출 해야한다는 것이다**
단순히 저수준 모듈에서 인터페이스와 클래스를 분리하는 개념이 아닌 고수준 모듈을 기준으로 인터페이스를 추출해야한다.

![[Pasted image 20230102212855.png|400]]
위와 같은 구조를 목표로 설계해보자.


#### 도메인 영역의 주요 구성요소

도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심 로직을 구현한다.

| 요소      | 설명                                                                                                            |
| ------- | ------------------------------------------------------------------------------------------------------------- |
| 엔티티     | 고유 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다.                                                                              |
| 밸류      | 고유 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용한다.                                                                 |
| 애그리거트   | 애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다. |
| 레포지토리   | 도메인 모델의 영속성을 처리한다. DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 역할을 한다.                                                      |
| 도메인 서비스 | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로하면 도메인 서비스에서 로직을 구현한다.                                    |

도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은것이 아니다.
두 모델의 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점이다.
예를 들어 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공한다.

도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이토 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다.

##### 애그리거트
도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현한다. → 복잡성 증가
도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 바로 애그리거트이다.

애그리거트의 대표적인 예가 주문이다.
주문이라는 도메인 개념은 '주문', '배송지 정보', '주문자', '주문 목록', '총 결제 금액'의 하위 모델로 구성된다.
애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게된다.

애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다.
루트 엔티티는 애그리거트에 속해있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
루트 애그리거트를 통해 하위 애그리거트와 밸류에 접근하게 함으로써 내부 구현을 숨기고 캡슐화 할 수 있도록 돕는다.

#### 요청 처리 흐름

controller → app service → domain service → repository

#### 인프라스트럭처 개요

...
인프라스트럭처에 대한 의존을 완전히 갖지 않도록 시도하는 것은 자칫 구현을 더 복잡하고 어렵게 만들 수 있다. (주의)

#### 모듈 구성

패키지 경로를 결정하는 내용인데, 이건 취향차이인듯하다.


---

### chepter3. 애그리거트

#### 애그리거트

애그리거트를 사용함으로써 모델 간의 관계를 개별 모델 수준과 상위 수준에서 모두 이해할 수 있다.
이해 뿐만아니라 일관성을 관리하는 기준도 된다.
애그리거트 단위로 일관성을 관리하기 때문에, 복잡성이 줄어든다.

한 애그리거트에 속한 애그리거트난 다른 애그리거트에 속하지 않는다.
애그리거트는 독립된 객체이며, 각 애그리거트는 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
(주문 애그리거트에서는 주문 상품 개수를 변경하지만, 회원의 비밀번호를 변경하지않는다.)

도메인 규칙에 따라 **함께 생성되는** 구성 요소는 한 애그리거트에 속할 가능성이 높다.

주의해야할건,
'A가 B를 갖는다'로 해석할 수 있는 요구사항이 있더라도 한 애그리거트에 속한다는것을 의미하지 않는다.
예를들어 제품과 리뷰가 있을때 제품이 리뷰를 갖기때문에 한 애그리거트라고 볼 수 있지만
제품이 생성될 때 리뷰가 함께 생성되지 않는다. 함께 변경되지도 않는다.


#### 애그리거트 루트

애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안된다.
도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다.
OrderLine을 변경하면 Order의 totalAmounts도 다시 계산을 해야한다는 소리이다.

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데,
그것은 애그리거트의 루트 엔티티이다.

하나의 트랜잭션에서는 하나의 애그리거트만 수정하는게 좋다. (Lock때문에) → 따로 트랜잭션 공부를 진행하자.
물론 실무에서 힘들수도있다!

#### 레포지토리와 애그리거트
→ 4장의 RDBMS와 JPA 이용하는 방법 참고

#### ID를 이용한 애그리거트 참조
하나의 애그리거트에서 다른 애그리거트의 상태값을 바꿀때에 대한 문제점 제시
→ ID참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
예시
![[Pasted image 20230103004039.png|400]]
Members는 Order라는 애그리거트 루트 엔티티에 속하지 않는다.
이때 구현 방식에 따라 `orderer.getMember().changeAddress('주소')` 와 같은 형태로
다른 애그리거트의 상태값을 변경 할 수 있다.
위와 같은 방법은 애그리거트간의 결합도를 올리며 변경에 대해 어렵게 만든다.
때문에 `memberRepository.findById(orderer.getMemberId())`와 같이 id값을 통해 member를 조회하고 수정한다.

#### 애그리거트 간 집합 연관

당연하게도 페이지네이션을 구현해야할때 굳이 루트 엔티티를 통해서 구현 할 필요 없이 해당 도메인의 repository를 통해 구현하면된다.
M-N(다대다) 관계같은경우
...
사용할일 없을것 같아서 나중에 필요하면 책 찾아보자. (p.123)
...

#### 애그리거트를 팩토리로 사용하기
애그리거트가 갖고있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면
애그리거트에 팩토리 메서드(`store.createProduct(id..생략)`) 메서드를 추가해서 사용해보자
store에서 하지않고 Factory 클래스를 만들어 사용해도 좋다.

---

### chepter4. 레포지토리와 모델 구현
#### JPA를 이용한 레포지토리 구현
#### 스프링 데이터JPA를 이용한 레포지토리 구현
#### 매핑 구현

![[Pasted image 20230103013120.png|400]]
>@SecondaryTable, @Embeddable, @AttributeOverride 등 공부 필요함.
>@SecondaryTable을 사용하면 루트 엔티티를 조회할때 SecondaryTable을 join 해서 가져온다.

선언하는게 여태 썻던거랑 너무다른데..?
지금은 졸리니 내일 다시 정리하자.

애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.
루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 한다.
단지 별도 테이블에 데이터를 저장 한다고 해서 엔티티인 것은 아니다.
주문 애그리거트도 OrderLine을 별도 테이블에 저장하지만 OrderLine 자체는 엔티티가 아니라 밸류이다.

밸류가 아니라 엔티티가 확실하다면 엔티티가 아니라 애그리거트인지 확인해야 한다.
자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.

**함께 속한 애그리거트는 생성이 같이되거나 수정될 때 영향을 받는다. 주의하자**

밸류는 @Embeddable로 매핑한다.

#### 애그리거트 로딩 전략

무조건적인 Lazy 또는 Eager 방식은 옳지못하다.
한 애그리거트에서도 여러 상황에 따라 방식을 다르게 가져가자

#### 애그리거트의 영속성 전파

애그리거트는 완전한 상태여야한다.
루트 엔티티 조회 뿐만아니라 저장하고 삭제할때도 하나로 처리되어야 한다.

Cascade의 사용
CascadeType.PERSIST, CascaseType.REMOVE, orphanRemoval=true 를 설정한다.

#### 식별자 생성 기능

Id값 생성에대한이야기...

#### 도메인 구현과 DIP

급하니 넘어가도 될만한 이야기...

---

### chepter5. 스프링 데이터 JPA를 이용한 조회 기능
#### 시작에 앞서
#### 검색을 위한 스펙
#### 스프링 데이터 JPA를 이용한 스펙 구현
#### 레포지토리 / DAO에서 스펙 사용하기
#### 스펙 조합
#### 스펙 조합을 위한 스펙 빌더 클레스

책에서는 spec이란걸 사용했지만, querydsl을 사용하면 문제 없어보인다.

#### 정렬 지정하기
#### 페이징 처리
jpa에서 orderBy를 사용하는것보다 매개변수로 Sort를 보내주는것이 함수명을 더 짧게 가져갈 수 있다.
마찬가지로 Pageable 매개변수 사용하라는 내용
PageRequest를 사용하면 페이징처리와 정렬 동시에 가능하다는 내용

#### 동적 인스턴스 생성
Projection과 같이 db에 없는 객체를 JPQL로 생성한다는 내용 

#### 하이버네이트 @Subselect 사용

수정불가능한 조회용 Entity를 db와 매핑 할 수 있다는 내용
당장에 사용하지 않을듯 하다.

---

### chepter6. 응용 서비스와 표현 영역
#### 표현 영역과 응용 영역
#### 응용 서비스의 역할
#### 응용 서비스의 구현
#### 표현 영역
#### 값 검증
#### 권한 검사
#### 조회 전용 기능과 응용 서비스

---

### chepter7. 도메인 서비스
#### 여러 애그리거트가 필요한 기능
#### 도메인 서비스

---

### chepter8. 애그리거트 트랜잭션 관리
#### 애그리거트와 트랜잭션
#### 선점 잠금
#### 비선점 잠금
#### 오프라인 선점 잠금

---

chepter9부터는 개발하면서 공부해야겠다.

### chepter9. 도메인 모델과 바운디드 컨텍스트
#### 도메인 모델과 경계
#### 바운디드 컨텍스트
#### 바운디드 컨텍스트 구현
#### 바운디드 컨텍스트 간 통합
#### 바운디드 컨텍스트 간 관계
#### 컨텍스트 맵

---

### chepter10. 이벤트
#### 시스템 간 강결합 문제
#### 이벤트 개요
#### 이벤트, 핸들러, 디스패처 구현

---

### chepter11. CQRS
#### 단일 모델의 단점
#### CQRS

![[Pasted image 20230103144412.png|400]]
![[Pasted image 20230103144542.png|400]]
