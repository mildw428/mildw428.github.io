---
layout: default
title: JWT
parent: memo
---
# JWT
---

## session

세션은 서버의 메모리에 생성되는 저장 공간이다. 이 안에 로그인한 유저의 정보가 저장이 된다. 세션에 저장된 정보에는 고유의 세션ID가 부여된다. 사용자가 로그인을 하면 서버는 쿠키에 세션ID를 실어서 브라우저에게 보내준다.

기존에 구현한 `Session`은 로그인 하면
1.  Session에 로그인 정보를 저장하고 그 정보를 이용한다.
2.  로그인을 하면 Session Id가 생성되어 Front End에 쿠키로 전달되고, 그 난수가 Session에 저장된다.
3.  이후 클라이언트의 요청이 있을 때 마다 withCredentials 설정을 통해 함께 전달된 쿠키를 Session에 저장된 정보와 확인한다.
4.  이후 확인이 완료되면 DB에서 해당 유저정보를 가져와 Request의 user에 값을 넣어준다.

---
#### 쿠키의 세션 아이디를 다른 컴퓨터에 저장하면 로그인이 될까?
>결론만 말하자면 가능하다.  
>로그인이 가능한 웹사이트에서 로그인 후에 JSESSIONID(톰캣 서버가 부여해준 세션 쿠키 ID)를 로그인 된 Session Id로 바꿔치기 해주면 Id, Password 없이 로그인이 된다.  그럼 보안이 너무 취약한 것 아니야? 라고 생각할 수도 있다.  
>하지만 이 방식으로 로그인이 가능해지려면 웹사이트가 SSL이 적용되어있지 않은 Http 사이트여야한다. 
>요즘 대부분의 사이트는 Https로 SSL을 사용하기 때문에 이러한 문제는 발생하지 않는다.  
>SSL이 적용이 되면 송수신자는 공개키-비밀키 암호화 방식을 통해서 Session Id를 전달받기 때문에 송수신자가 일치하지 않으면 로그인을 시켜주지 않는다.  
>이로인해 중간자 공격, 세션 하이재킹, 스니핑 공격 등으로부터 안전해진다.
---

**▪ 저장 공간의 용량**
세션은 서버의 **메모리 내부**에 저장이 된다. 유저가 한두명일때야 메모리에 무리가 가지 않겠지만 유저가 수천명인 대형 서비스에서는 세션의 양이 많아지는 만큼 메모리에 부하가 걸릴 수 있다.

**▪ 확장성의 문제**
서비스의 규모가 커져서 서버를 여러대로 확장 및 분산해야 한다면 세션을 분산시키는 기술을 따로 설계해야 한다.

이를 해결하기 위해 보통 JWT라는 로그인 방식을 도입한다.

---

##  jwt

>stateless와 stateful:
>상태값을 서버에서 저장하고 있다는 의미.
>HTTP는 무상태(stateless) 프로토콜이므로 상태를 유지하기 위해 모든 request에 cookie를 보낸다.

>bearer token:
>Authorization 헤더에 "Bearer 토큰이런식으로보내는데의을헤더의토큰"이런식으로보내는데oauth의accesstoken을헤더의{토큰} 영역에 담아서 요청에 사용한다. 참고로 access_token은 서버에서 쿠키처럼 액세스토큰 저장소에 저장해서 상태(stateful) 형태로 구현할수 있고 jwt 토큰을 써서 무상태로 구현할 수 있다.

>jwt:
>json web token의 약자로 header, payload, signature로 구성되어 있다. base64로 인코딩 되어있기 때문에 디코딩하면 사용자 식별정보들을 볼 수 있다. 악의적인 변조를 막기 위해 signature 영역은 암호화 알고리즘을 적용해서 서버에서는 사용자로부터 받은 request의 유효성을 확인하기 위해 signature 부분을 통해 validate를 진행하고 성공시 payload 영역을 base64 디코딩하고 json 문자열을 파싱해서 사용자 식별을 위한(java로 예를 들면 Principal이 될 수 있겠다.) 객체를 만들고 이를 통해 authorization을 진행

```
-   `iss`: 토큰 발급자 (issuer)
-   `sub`: 토큰 제목 (subject)
-   `aud`: 토큰 대상자 (audience)
-   `exp`: 토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정되어있어야합니다.
-   `nbf`: Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.
-   `iat`: 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 `age` 가 얼마나 되었는지 판단 할 수 있습니다.
-   `jti`: JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.
```

참고 : [보안](https://code-machina.github.io/2019/09/01/Security-On-JSON-Web-Token.html)
참고 : [보안](https://beoksuya.tistory.com/153)

JWT는 JSON Web Token의 약자로 전자 서명된 URL-safe(URL로 이용할 수 있는 문자로 구성된)의 JSON으로 유저를 인증하고 식별하기 위한 토큰(Token) 기반 인증이며, RFC 7519를 통해 자세한 명세를 확인할 수 있다.

웹에서 사용자 인증 정보를 클라이언트에 보관하는 쿠키 방식이 보안에 취약하다는 이유로
서버 측에 인증 정보를 보관하는 점점 세션을 권장 및 사용하는 형태로 변경되었지만
JWT는 다시 인증 정보를 토큰에 심고 클라이언트에 보관하는 방식을 채택했다.

JWT는 JSON 데이터를 Base64 URL-safe Encode를 통해 인코딩하여 직렬화한 것이 포함되며,
토큰 내부에는 위변조 방지를 위해 개인키를 이용한 전자서명도 있다.
따라서 사용자가 JWT를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며, 검증이 완료되면 요청한 응답을 돌려준다.

### Access Token & Refresh Token

Refresh Token은 Access Token과 똑같은 형태의 JWT이다. Refresh Token은 긴 유효기간을 가지면서, Access Token이 만료됐을 때 새로 발급해주는 열쇠가 된다.

### 인증 순서

일반적으로 JWT를 사용하는 경우 아래와 같은 순서로 진행된다.
1) 클라이언트 사용자가 아이디, 패스워드를 통해 웹 서비스 인증
2) 서버에서 서명된(Signed) JWT를 생성하여 클라이언트에 응답으로 회신
3) 클라이언트가 서버에 데이터를 추가적으로 요구할 때 JWT를 HTTP Header 또는 URL 파라미터로 첨부
4) 서버에서 클라이언트로부터 온 JWT를 검증

- 장점
	JWT를 이용하면 따로 서버의 메모리에 저장 공간을 확보할 필요가 없다. 서버가 토큰을 한번 클라이언트에게 보내주면 클라이언트는 토큰을 보관하고 있다가(가장 쉬운 방법은 localstorage에 저장하는 것이다) 요청을 보낼때마다 헤더에 토큰을 실어보내면 된다. 쿠키를 사용할 수 없는(쿠키는 웹브라우저에서 사용할수 있는 기능이다!) **모바일 어플리케이션**에는 JWT를 사용한 인증방식이 최적이다.

- 단점
	JWT는 HTTP를 통해서 전송하기 때문에 페이로드의 크기가 클수록 데이터 전송에 있어서 비용이 커진다.
	JWT는 유효기간을 따로 정하지 않는 이상 소멸되지 않기 때문에 장기간 방치시 해킹의 위험이 커진다.
	JWT를 localstorage에 보관한다면 XSS공격에 취약해진다.
	- (XSS는 외부의 해커가 우리의 프 로그램에 특정 javascript 코드를 심어서 localstorage에 접근하는 공격이다.)
	- 보통 httpOnly가 설정되서 브라우저만 접근 가능한 쿠키에 토큰을 실어보내서 XSS 공격을 막는다.
