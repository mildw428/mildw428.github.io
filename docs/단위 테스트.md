---
layout: default
title: 단위 테스트
nav_order: "4"
---
# 단위 테스트
---

# 1장

```
단위 테스트와 코드 설계의 관계

코드를 단위 테스트하기 어렵다면 코드 개선이 반드시 필요하다는 것을 의미한다.
보통 강결합에서 저품질이 나타나는데, 여기서 강결합은 제품 코드가 서로 충분히 분리되지 않아서 따로 테스트하기 어려움을 뜻한다.

안타깝게도 코드베이스를 쉽게 단위 테스트할 수 있다고 해도 반드시 코드 품질이 좋은것을 의미하지 않는다.
```

단위테스트의 목표?
소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는것이다.

테스트가 없는 프로젝트의 경우 시작은 유리하지만, 이내 진척이 없을 정도로 느려진다.

코드베이스에서 무언가 변경할 때마다 무질서도는 증가한다. 지속적인 정리와 리팩터링 등과 같은 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해진다.

테스트는 안전망 역할을 한다. 새 기능을 도입하거나 새로운 요구사항에 맞게 리팩터링한 후에도 기존 기능이 잘 동작하는지 확인하는데 도움이 된다.

모든 테스트를 작성할 필요는 없다. 일보 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 지속 가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중해야 한다.

# 2장
단위 테스트란 무엇인가

정의
- 작은 코드 조각을 검증
- 빠르게 수행
- 격리된 방식으로 처리하는 자동화된 테스트

문제는 3번째 속성으로 격리의 문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이에 속한다. 두 분파의 차이는 격리가 정확히 무엇인지에 대한 의견 차이 하나로 시작된다.

##### 런던파의 접근
런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다.

즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존석을 테스트 대역으로 대체해야 한다. (mock 객체를 사용한다는 뜻)

##### 고전파의 접근
고전적인 방법에서는 코드를 꼭 격리시키는 방식으로 테스트해야 하는 것은 아니다.

대신 단위 테스트는 서로 격리해서 실행시켜야한다.

예를 들어 어떤 테스트가 준비 단계에서 데이터베이스에서 고객을 생성할 수 있고, 이 테스트가 실행되기 전에 다른 테스트의 준비 단계에서 고객을 삭제할 수도 있다. 이 두 가지 테스트를 병렬로 실행하면 첫 번째 테스트가 실패하는데, 이는 제품이 고장 나서가 아니라 두 번째 테스트의 간섭 때문이다.

```
공유 의존성
테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다.
데이터베이스도 공유 의존성의 전형적인 예가 될 수 있다.

비공개 의존성
공유하지 않는 의존성이다.

프로세스 외부 의존성
애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시다. 외부 의존성은 대부분 공유 의존성에 해당하지만 모두 그런것은 아니다. 예를 들어 DB를 도커 컨테이너로 시작한다면 테스트가 더이상 동일한 인스턴스로 동작하지 않기 때문에 외부이면서 공유하지 않는 의존성이 된다.

휘발성 의존성
다음 속성 중 하나를 나타내는 의존성이다
- 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구한다. 데이터베이스와 api 서비스가 좋은 예다. 추가 설정이 필요하며 시스템에 기본으로 설치돼 있지 않다.
- 비결정적 동작을 포함한다. 예를 들어 난수 생성기 또는 현재 날짜와 시간을 반환하는 클래스 등이 있다. 이런 의존성은 각 호출에 대해 다른 결과를 제공하기 때문에 비결정적이라 한다.
```

공유 의존성은 거의 항상 실행 프로세스 외부에 있는 데 반해, 비공개 의존성은 보통 그 경계를 넘지 않는다. 따라서 데이터베이스나 파일 시스템 등의 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 더 오래 걸린다. 그리고 단위 테스트 두 번째 속성으로 빨리 실행해야 하는 필요성이 있으므로, 이러한 호출을 포함하는 공유 의존석을 가진 테스트는 단위 테스트 영역에서 통합 테스트 영역으로 넘어간다.

런던파와 고전파의 나눠진 원인은 격리 특성에 있다.
런던파는 테스트 대상 시스템에서 협력자를 격리하는것
고전파는 단위 테스트끼리 격리하는것


|     | 격리 주체  | 단위의 크기           | 테스트 대역 사용 대상    |
| --- | ------ | ---------------- | --------------- |
| 런던파 | 단위     | 단일 클래스           | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성          |

런던파의 이점
- 입자성이 좋다. 테스트가 세밍해서 한 번에 한 클래스만 확인한다.
- 서로 연결된 클래스의 그랲프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문에 테스트 작성 시 걱정할 필요가 없다.
- 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다.


테스트의 단위는 너무 작아서는 안된다. 이 테스트가 무엇을 검증하는지 정확하게 이해하기가 어려워지기 때문이다. 응집도가 높도 의미가 있어야한다.

예를들어
우리집 강아지를 부르면, 바로 나에게 온다.

우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다.

실제 동작(개가 주인에게 오는 것)대신 개별 클래스(다리, 머리, 꼬리)를 목표로 할 때 테스트가 이렇게 보이기 시작한다.

#### 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.

고전파를 따라 테스트 대상 시스템을 설정하려면 전체 객체 그래프를 다시 생성해야 하는데, 작업이 많을 수 있다.

모두 사실이지만, 잘못된 문제에 초점을 맞추고 있다. 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대게 클래스가 커진 것은 코드 설계 문제의 결과이다.

목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.

### 버그 위치 정확히 찾아내기
런던 스타일과 달리 고전 스타일은 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급 효과를 초래한다. 결국 원인을 찾기가 더 어려워진다. 문제를 파악하고 디버깅하는데 시간이 걸릴 수 있다. 하지만 큰 문제는 아니다. 테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다. 즉 마지막으로 수정한게 무엇인지 알기 때문에 문제를 찾는게 그리 어렵지않다.

### 고전파와 런던파 사이의 다른 차이점
- 테스트 주도 개발을 통한 시스템 설계 방식
- 과도한 명세 문제

가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 구현 세부 사항에 결합되는 것이다. 런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다.

## 두 분파의 통합 테스트
런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다.
고전 스타일로 작성된 대부분의 테스트는 런던파 지지자들에게 통합 테스트로 느껴질 것이다.

다시 말하지만, 단위 테스트는 다음과 같은 특징이 있는 자동화된 테스트다.
- 작은 코드 조각을 검증하고
- 빠르게 수행하고
- 격리된 방식으로 처리한다.


통합테스트는 이러한 기준 중 하나를 충족하지 않는 테스트다.
공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다
외부 의존성에 접근하면 테스트는 느려진다
둘 이상의 동작 단위를 검증할 때의 테스트는 통합 테스트다



# 3장

## 단위 테스트를 구성하는 방법
### AAA 패턴
준비, 실행, 검증

```java
public void sum_of_two_numbers() {
	//준비
	double first = 10;
	double second = 20;
	var calculator = new Calculator();

	//실행
	double result = calculator.sum(first, second);

	//검증
	Assert.Equal(30, result);
}
```

### 테스트 내 if문 피하기
if문이 있는 단위 테스트를 만날 수 있는데, 이것은 안티 패턴이다. 단위 테스트든 통합 테스트든 테스트는 분기가 없는 간단한 일련의 단계여야 한다. if문은 테스트가 한번에 너무 많은 것을 검증한다는 표시다.

### 각 구절은 얼마나 커야 하는가?
준비 구절이 가장 큰 경우
너무 크다면 팩토리 클래스로 도출하는 것이 좋다. 코드 재사용에 도움이 되는 두가지 패턴으로 오브젝트 마더와 테스트 데이터 빌더가 있다

```java

// 오브젝트 마더 클래스 정의
class UserObjectMother {
    // 특정 상태의 사용자를 생성하는 메서드
    public static User createActiveUser() {
        return new User("activeuser", "activeuser@example.com");
    }

    public static User createInactiveUser() {
        return new User("inactiveuser", "inactiveuser@example.com");
    }
}

public class Main {
    public static void main(String[] args) {
        // 오브젝트 마더 패턴을 사용하여 사용자 생성
        User activeUser = UserObjectMother.createActiveUser();
        User inactiveUser = UserObjectMother.createInactiveUser();

        // 생성된 사용자 출력
        System.out.println("Active User: " + activeUser.getUsername() + ", " + activeUser.getEmail());
        System.out.println("Inactive User: " + inactiveUser.getUsername() + ", " + inactiveUser.getEmail());
    }
}

```


```java

//테스트 빌더 패턴 예제
import java.util.Random;


// 테스트 데이터 빌더 클래스 정의
class TestDataBuilder {
    private static Random random = new Random();

    // 임의의 사용자 생성 메서드
    public static User createRandomUser() {
        // 임의의 사용자 이름과 이메일 생성
        String username = "user" + random.nextInt(1000);
        String email = "user" + random.nextInt(1000) + "@example.com";

        // 사용자 객체 생성하여 반환
        return new User(username, email);
    }
}

public class Main {
    public static void main(String[] args) {
        // 테스트 데이터 빌더를 사용하여 랜덤 사용자 생성
        User user1 = TestDataBuilder.createRandomUser();
        User user2 = TestDataBuilder.createRandomUser();

        // 생성된 사용자 출력
        System.out.println("User 1: " + user1.getUsername() + ", " + user1.getEmail());
        System.out.println("User 2: " + user2.getUsername() + ", " + user2.getEmail());

        // 사용자 정보 수정
        user1.setUsername("newusername");
        user2.setEmail("newemail@example.com");

        // 수정된 사용자 정보 출력
        System.out.println("Modified User 1: " + user1.getUsername() + ", " + user1.getEmail());
        System.out.println("Modified User 2: " + user2.getUsername() + ", " + user2.getEmail());
    }
}

```


실행 구절이 한 줄 이상인 경우를 경계해라
보통 실행 구절은 한 줄이다.

```java
public void pruchase_successds_when_enough_inventory() {
	//준비
	var store = new Store();
	store.addInventory(Product.Shampoo,10);
	var customer = new Customer();
	//실행
	bool success = customer.purchase(store, Product.Shampoo, 5);
	store.RemoveInventory(success, Product.Shampoo, 5);
	//검증
	Assert.True(success);
	Assert.Equal(5, store,GetInventory(Product.Shampoo));
}
```

해당 코드는 테스트에는 문제가 없지만 실제 비즈니스 로직에서 구매 메서드를 실행하고 RemoveInventory를 실행하지 않으면 모순이 생긴다. 이러한 모순을 불변 위반이라고 하며, 모순으로부터 안전하기 위해 캡슐화를 한다. 

검증 구절에는 검증문이 얼마나 있어야 하는가?
단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다. 하지만 검증 구절이 너무 커지는것은 경계해야 한다. 제품 코드에서 추상화가 누락됐을 수 있다.

종료 단계는 어떤가?
검증 이후에 종료단계를 두는 경우도 있다. 예를 들면 테스트에 의해 작성된 파일을 지우거나 DB연결을 종료하고자 종료 단계를 사용한다.

## 테스트 간 테스트 픽스처 재사용
테스트에서 언제 어떻게 코드를 재사용하는지 아는것이 중요하다. 준비 구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법이다.

테스트 픽스처를 재사용하는 첫 번째 방법은 다음과 같이 테스트 생성자에서 픽스처를 초기화하는 것이다.

```java
public class CustomerTests {
	private readonly Store _store;
	private readonly Customer _sut;

	// 클래스 내 각 테스트 이전에 호출
	public CustomerTests() {
		_store = new Store();
		_store.AddInventory(Product. Shampoo, 10);
		_sut = new Customer();
	｝
	
	[Fact]
	public void Purchase_succeeds when_enough_inventory() {
		bool success = _sut.Purchase(_store, Product.Shampoo, 5);
		Assert.True(success);
		Assert.Equal (5, _store.GetInventory(Product.Shampoo));
	｝
	
	[Fact]
	public void Purchase_fails when _not_enough_inventory()｛
		bool success = _sut.Purchase(_store, Product.Shampoo, 15);
		Assert.False(success);
		Assert.Equal (10, _store.GetInventory(Product.Shampoo));
	}
}
```

위와 같은 방법으로 준비 구절을 추출할 수 있는데, 이것은 두가지 단점이 있다
- 테스트 간 결합도가 높아진다
	- 테스트 간의 높은 결합도는 안티 패턴이다
	- 변경으로 인해 다른 테스트에 영향을 줄 수 있다
- 테스트 가독성이 떨어진다
	- 또한 테스트만 보고는 더이상 전체 그림을 볼 수 없다

## 더 나은 픽스처 재사용법
```java
public class CustomerTests
{
	[Fact]
	public void Purchase_succeeds_when_enough_inventory() {
		Store store = CreateStoreWithInventory (Product. Shampoo, 10);
		Customer sut = CreateCustomer ();
		bool success = sut. Purchase(store, Product. Shampoo, 5);
		Assert. True (success) ;
		Assert. Equal (5, store.GetInventory (Product.Shampoo));
	}
	
	[Fact]
	public void Purchase_fails_when_not_enough_inventory() {
		Store store = CreateStoreWithInventory (Product. Shampoo, 10);
		Customer sut = CreateCustomer ();
		bool success = sut. Purchase(store, Product. Shampoo, 15);
		Assert. False(success) ;
		Assert. Equal(10, store.GetInventory(Product.Shampoo));
	}
	
	private Store CreateStoreWithInventory(Product product, int quantity)｛
		Store store = new Store();
		store.addInventory(product, quantity);
		return store;
	}
	
	private static Customer createCustomer() {
		return new Customer();
	}
}
```

## 단위 테스트 명명법
`[테스트 대상 메서드]_[시나리오]_[예상결과]`
- 엄격한 정책을 따르지 않는다. 복잡한 동작에 대한 높은 수준을 설명하려면 좁은 정책 안에서 해결할 수 없다
- 비 개발자에게 설명하는 것처럼 이름을 짓자
- `underscore(_)`를 통해 가독성을 향상 시키자

## 매개변수화 된 테스트 리팩터링하기

```java
public class DeliveryServiceTests {

	//[InlineData] 특성은 테스트 메서드에 입력 값 집합을 보낸다.
	//각 라인은 동작에 대해 별개의 사실을 나타낸다.
	[InlineData(-1, false)]
	[InlineData(0, false)]
	[InlineData(1, false)]
	[InlineData(2, true)]
	[Theory]
	public void Can_detect_an_invalid_delivery_date(int daysFromNow,
													bool expected) {
		DeliveryService sut = new DeliveryService();
		DateTime deliveryDate = DateTime. Now
		.AddDays (daysFromNow);
		Delivery delivery = new Delivery
		Date = deliveryDate
		bool isValid = sut. IsDeliveryValid(delivery);
		Assert. Equal (expected, isValid);
	}
}
```

동작이 너무 복잡하면 매개변수화된 테스트를 조금도 사용하지 말것을 추천한다

# 4장
좋은 단위 테스트의 4대 요소
- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

## 회귀 방지
회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야한다.
회귀란 소프트웨어 버그이다.
- 테스트 중에 실행되는 코드의 양
	- 일반적으로 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
- 복잡도와 도메인 유의성
	-  비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 떄문이다.
- 외부 라이브러리

> 회귀 방지 지표를 극대화하려면 테스트가 가능한 많은 코드를 실행하는 것을 목표로 해야 한다.

## 리팩터링 내성
이는 테스트를 빨간색으로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.

모든것을 완벽하게 동작하게 리팩터링 했다. 테스트코드가 실패하고 있다는 것만 빼고, 정확히 무엇이 고장났는지 확인해 봤지만, 알고 보니 아무것도 고장나지 않았다. 기능은 예전과 같이 완벽하게 동작한다. 문제는 코드를 수정하면 테스트가 빨간색으로 바뀌게끔 작성됐다는 것이다. 이러한 상황을 거짓 양성이라고 한다. 거짓 양성은 허위 경보이다.

> 아니 이책은 왜 거짓 양성이란 어려운말을쓰지? 허위 경보라고 작성하면 다들 알아듣기 편할텐데?

### 거짓 양성의 원인
테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합 할수록 허위 경보가 더 많이 생긴다.
줄이는 방법은 구현 세부사항에서 테스트를 분리하는 것 뿐이다.
테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다. 테스트는 최종 사용자의 관점에서 sut를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다. 다른 모든 것은 무시해야 한다.

```java
public class Message {
	public String header {get;set;}
	public String body {get;set;}
	public String footer {get;set;}
}

public interface IRenderer {
	String render(Message message);
}
public class MessageRenderer : IRenderer {
	public IReadOnlyList<IRenderer> subRenderers {get;}
	public MessageRenderer() {
		subRenderers = new List<IRenderer> {
			new HeaderRenderer().
			new BodyRenderer(),
			new FooterRenderer()
		};
	}
	public String render(Message message) {
		return subRenderers.select(x->x.render(message))
				.aggregate("", (str1, str2) -> str1 + str2)
	}
}
```

```java
public class BodyRenderer : IRenderer {
	public String Render(Message message) {
		return $"<b>{message.body}</b>";
	}
}
```

MessageRenderer를 어떻게 테스트할 수 있을까?

```java
public void MessageRenderer_uses_correct_sub_renderers) {
	var sut = new MessageRenderer ();
	
	IReadOnlyList< IRenderer> renderers = sut.SubRenderers;
	
	Assert. Equal (3, renderers. Count);
	Assert. IsAssignableFrom<HeaderRenderer>(renderers [0]);
	Assert. ISAssignableFrom<BodyRenderer> (renderers (1]);
	Assert. IsAssignableFrom<FooterRenderer>(renderers [2]);
}
```
위 테스트는 하위 렌더링 클래스가 예상하는 모든 유형이고 올바른 순서대로 나타나는지 여부를 확인한다. 여기서 MessageRenderer가 메시지를 처리하는 방식도 정확해야 한다고 가정한다. 처음에는 테스트가 좋아보이지만, MessageRenderer의 식별할 수 있는 동작을 실제로 확인하는가? 하위 렌더링 클래스를 재배열하거나 그중 하나를 새 것으로 교체하면 어떻게 될까? 버그로 이어지는가?
반드시 그렇지는 않다. 하위 렌더링 클래스의 구성을 변경해도 HTML 문서가 동일하게 유지될 수 있다. 예를들어 BodyRenderer를 동일한 작업을 수행하는 BoldRenderer로 바꿀 수 있다. 또는 모든 하위 렌드링 클래스를 제거하고 MessageRenderer에서 직접 렌더링을 구현할 수도 있다.
최종 결과가 바뀌지 않을지라도, 테스트를 수행하면 빨간색으로 변할 것이다. 이는 테스트가 sut가 생성한 결과가 아니라 sut의 구현 세부와 결합했기 때문이다.

### 구현 세부 사항 대신 최종 결과를 목표로 하기
```java
[Fact]
public void Rendering_a_message() {
	var sut = new MessageRenderer ();
	var message = new Message
	Header = "h"，
	Body = "b",
	Footer = "f"
	string html = sut. Render (message);
	Assert.Equal("<h1>h</h1>‹b>b</b><i>f‹/i>", html);
}
```
MessageRenderer를 블랙박스 취급하고 식별할 수 있는 동작에만 신경쓴다. 이로인해 리팩터링 내성이 증가했다.

## 빠른 피드백과 유지 보수성
유지보수성 지표는 유지비를 평가한다. 다음 두가지 주요 요소로 구성된다.
- 테스트가 얼마나 이해하기 어려운가
	- 테스트 코드의 품질은 제품 코드만큼 중요하다.
- 테스트가 얼마나 실행하기 어려운가
	- 외부 종속성으로 작동하면, 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 상시 운영하는데 시간을 들여야 한다.

## 이상적인 테스트를 찾아서
4가지 요소를 모두 만족시키는 이상적인 테스트를 만드는것은 불가능하다. 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 떄문이다. 셋중 하나를 희생해야 나머지 둘을 최대로 할 수 있다.

1. 엔드 투 엔드 : 빠른 피드백 희생
2. 간단한 테스트 : 무의미한 테스트로 인해 회귀 희생
3. 깨지기 쉬운 테스트 : 거짓 양성이 많은 테스트를 작성하기 쉽다. 리팩터링 내성 희생

결론
다 챙기는것은 불가능 하다. 하지만 리팩터링 내성은 꼭 챙겨야 한다.  이유는 다른 특성은 절충안이 있지만 리팩터링 내성은 0아니면1이기때문에 회귀 방지나 빠른 피드백 부분에서 절충안을 찾아야한다.


## 자동화 개념

### 테스트 피라미드 분해
테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념이다

- 엔드 투 엔드
- 통합 테스트
- 단위 테스트
아래로 갈수록 테스트 수가 많음
위로 갈수록 최종 사용자 경험에 가깝게 흉내

예외적으로 비즈니스 규칙이나 기타 복잡도가 없는 기본적인 crud라면, 테스트 피라미드는 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형처럼 보일것이다.

단위 테스트는 알고리즘이나 비즈니스 복잡도가 없는 환경에서는 유용하지 않다.
통합 테스트는 코드가 아무리 단순하더라도 데이터베이스와 같이 다른 하위 시스템과 통합되어 잘 작동하는지 확인하는것이 중요하다.

### 블랙박스 테스트와 화이트박스 테스트
- 블랙박스 : 내부 구조를 몰라도 검사할 수 있는 테스트방법
- 화이트박스 : 그 반대

장단점

|        | 회귀방지 | 리팩터링 내성 |
| ------ | ---- | ------- |
| 화이트 박스 | 좋음   | 나쁨      |
| 블랙 박스  | 나쁨   | 좋음      |

테스트를 작성할 때는 블랙박스 방법을, 테스트를 분석할때는 화이트박스 방법을 사용

# 5장
목과 테스트 취약성

## 목과 스텁 구분
테스트 대역 유형
테스트 대역의 주 용도는 테스트를 편리하게 하는것이다.
테스트 대상 시스템으로 실제 의존성 대신 전달되므로 설정이나 유지보수가 어려울 수 있다.

테스트 대역에는
더미, 스텁, 스파이, 목, 페이크 라는 다섯가지가 있다.
- 목 (목, 스파이) 
	- 외부로 나가는 상호작용을 모방하고 검사하는데 도움을 준다. 이러한 상호 작용은 sut가 상태를 변경하기 위한 의존석을 호출하는 것에 해당한다.
- 스텁 (스텁, 더미, 페이크)
	- 내부로 들어오는 상호작용을 모방하는데 도움을 준다. 이러한 상호 작용은 sut가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.

테스트 대상 시스템(sut) -> 이메일 발송 (mock) - > smtp 서버
테스트 대상 시스템(sut) -> 데이터 검색 (stub) - > 데이터베이스

스파이는 수동으로 작성하는 반면, 목은 목 프레임워크의 도움을 받아 생성된다.

더미는 null 값이나 가짜 문자열과 같이 단순하고 하드코딩된 값이다.
스텁은 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성이다.
페이크는 아직 존재하지 않는 의존성을 대체하고자 구현한다.

### 도구로서의 목과 테스트 대역으로서의 목
mock라이브러리를 사용하면 도구로서의 목(stub)과 테스트 대역으로서의 목 두가지 유형을 생성할 수 있기 때문에 헷갈려선 안된다.

### 스텁으로 상호 작용을 검증하지 말라

스텁은 sut가 출력을 생성하도록 입력을 제공할 뿐 검증을 하지 않는다.

리팩터링 내성을 향상 시키는 방법은 구현 세부 사항이 아니라 최종 결과를 검증하는 것이다.

최종 결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세라고 부른다. 과잉 명세는 상호 작용을 검사할 때 가장 흔하게 발생한다. 스텁과의 상호 작용을 확인하는 것은 쉽게 발견할 수 있는 결함이다. 테스트가 스텁과의 상호 작용을 확인해서는 안 되기 때문이다. 

목은 더 복잡하다. 목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만, 대다수가 그렇다.

목과 스텁의 개념은 명령 조회 분리 원칙(CQS)과 관련이 있다. 모든 메서드는 명령이거나 조회여야 하며, 이 둘을 혼용해서는 안된다. 이렇게 명확하게 분리하면 코드를 읽기 쉽다. 물론 항상 CQS 원칙을 따를 수 있는 것은 아니다. 전형적인 예로 stack.pop()이 있다. 그래도 가능하면 CQS를 따르는 것이 좋다.

명령을 대체 -> 목, 조회를 대체 -> 스텁

### 식별할 수 있는 독장은 공개 API와 다르다.
모든 제품 코드는 2차원으로 분류할 수 있다.
- 공개 API 또는 비공개 API
- 식별할 수 있는 동작 또는 구현 세부 사항
각 차원의 범주는 겹치지 않는다. 즉 메서드는 공개 API와 비공개 API 둘 다에 속할 수 없다.

식별할 수 있는 동작과 내부 구현 세부 사항에는 미묘한 차이가 있다. 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.
- 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드다.
- 클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.
구현 세부 사항은 이 두가지 중 아무것도 하지 않는다.

이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다.
공개 API - 식별할 수 있는 동작
비공개 API - 구현 세부 사항

> 실별할 수 있는 동작 -> 결과값

그러나 종종 시스템의 공개 API가 식별할 수 있는 동작의 범위를 넘어 구현 세부 사항을 노출하기 시작한다. 이러한 시스템의 구현 세부 사항은 공개 API로 유출된다.


클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙이 있다. 단일한 목표를 달성하고자 클래스에서 호출해야하는 연산의 수가 1보다 크면 해달 클래스에서 구현 세부 샇항을 유출할 가능성이 있다.

```java 
// 유출
String normalizedName = user.normalizedName(newName);
user.setName(normalizedName);

// 숨김
user.setName(newName);
```

캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다. 즉, 소프트웨어 프로젝트의 지속적인 성장을 가능하게 하는 것이다. 구현부 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다. 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

## 목과 테스트 취약성 간의 관계

육각형 아키텍처 정의
전형적인 애플리케이션은 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다.
도메인 계층은 애플리케이션의 중심부이기 때문에 도표의 중앙에 위치한다. 도메인에는 애플리케이션의 필수 기능으로 비즈니스 로직이 포함돼 있다. 도메인 계층과 해당 비즈니스 로직은 이 애플리케이션을 다른 애플리케이션과 차별화하고 조직의 경쟁력을 향상시킨다.

애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정한다. 예를 들어 애플리케이션이 Restful API인 경우 API에 대한 모든 요청이 먼저 애플리케이션 서비스 계층에 도달한다. 이 계층은 도메인 클래스와 프로세스 외부 의존성 간의 작업을 조정한다.
- 데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
- 해당 인스턴스에 연산 호출
- 결과를 데이터베이스에 다시 저장

육각형은 애플리케이션을 나타낸다. (서로 다른 애플리케이션 서비스와 연결되기 위해 모양을 육각형으로 표현한듯?)

- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
	- 비즈니스 로직은 애플리케이션의 가장 중요한 부분이다. 따라서 도메인 계층은 해당 비즈니스 로직에 대해서만 책임을 져야하며, 다른 모든 책임에서는 제외돼야 한다.
- 애플리케이션 내부 통신
	- 유각형 아키텍처는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단반향 의존성 흐름을 규정한다. 도메인은 외부인 애플리케이션 서비스에 의존하지 않는다.
- 애플리케이션 간의 통신
	- 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결된다. 아무도 도메인 계층에 직접 접근할 수 없다. 육각형은 내외부 연결을 의미한다.

목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다. 반대로 시스탬 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며, 그에 따라 리팩터링 내성 지표가 미흡해진다.

시스템 내부 통신과 시스템 간 통신 차이
- 고객이 상점에서 제품을 구매하려고 한다
- 매장 내 제품 수량이 충분하면
	- 재고가 상점에서 줄어든다
	- 고객에게 이메일로 영수증을 발송한다
	- 확인 내역을 반환한다

구매라는 동작은 시스템 내부 통신과 시스템 간 통신이 모두 있는 비즈니스 유스케이스다.
시스템간 통신 - 구매, 메일발송
시스템 내부 통신 - customer, store 도메인클래스 간의 통신

SMTP 서비스에 대한 호출을 목으로 하는 이유는 타당하다. 리팩터링 이후에도 이러한 통신 유형이 그대로 유지도되록 하기 때문에 테스트 취약성을 야기하지 않는다.

customer와 store의 경우 애플리케이션 경계를 넘지 않는다. 호출자와 수신자 모두 애플리케이션 내에 있다.
RemoveInventory()메서드(구매 후 store의 재고 -1 역할) 호출은 고객의 목표로 가는 중간 단계(구현 세부 사항)에 해당한다.

### 목을 사용한 동작 검증
종종 목이 동작을 검증한다고 한다. 하지만 대부분의 경우 그렇지 않다.  개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과는 아무런 관계가 없다. (이는 구현 세부 사항이다.)
클래스 간의 통신을 검증하는 것은 두뇌의 뉴런이 서로 통과하는 신호를 측정해 사람의 행동을 유추하는 것과 유사하다. (너무 세밀하다는 뜻)

# 6장
단위 테스트 스타일
- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트
하나의 테스트에서 둘, 세가지 스타일 모두 함께 사용할 수 있다.

### 출력 기반 테스트
테스트 대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식이다.
힘수형 이라고도 한다. 해당 테스트는 내부 컬렉션에 상품을 추가하거나 데이터베이스에 저장하지 않는다.
ex. 상품의 할인된 반환값을 검증한다.

### 상태 기반 스타일
작업이 완료된 후 시스템 상태를 확인하는 것이다. 이 테스트 스타일에서 상태라는 용어는 sut나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.
ex. 상품을 추가 한 후 컬렉션을 검증한다.

### 통신 기반 스타일 정의
목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.
협력자를 목으로 대체하고 sut가 협력자를 올바르게 호출하는지 검증한다.

## 단위 테스트 스타일 비교

리팩터링 내성 지표
출력 기반 테스트는 테스타 테스트 대상 메서드만 결합되므로 거짓 양성 방지가 가장 우수하다.
상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다. 이러한 테스트는 테스트 대상 메서드 외에도 클래스 상태와 함께 작동한다. 확률적으로 말하면, 테스트와 제품 코드 간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성이 커진다.
통신 기반 테스트가 허위 경보에 가장 취약하다. 테스트 대역으로 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽다. 애플리케이션 경계를 넘는 상호작용을 확인 하고 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮다.

여러가지 내용이 있지만 결론은 출력기반 테스트가 가장 좋다는 의견

함수형 프로그래밍을 기반으로 출력 기반 테스트를 진행한다.

메서드가 수학적 함수인지 판별하는 가장 좋은 방법은 프로그램의 동작을 변경하지 않고 해당 메서드에 대한 호출을 반환값으로 대체할 수 있는지 확인하는 것이다. 메서드 호출을 해당 값으로 바꾸는 것을 참조 투명성 이라고 한다.

함수형 아키텍처의 단점
실행의 흐름이 간단하지 않은 경우. 의사 결정 절차의 중간 결과에 따라 프로세스 외부 의존성에서 추가 데이터가 필요할 수 있다. 해결방법은 로직 전면부에서 필요한 데이터를 먼저 호출해 가능 방법이 있다. 하지만 이러한 방법은 성능 저하를 유발한다. 

함수형 하키텍처는 함수형 코어와 가변 셸 사이를 명확하게 분리해야하낟. 궁극적으로 코드 복잡도가 낮아지도 유지보수성이 향상되지만, 초기 코딩이 더 필요하다. 하지만 모든 시스템이 복잡도가 높고 중요하지않다. 시스템의 복잡도와 중요성을 고려해 함수형 아키텍처를 전략적으로 사용하자.

마지막으로 대부분의 모든 도메인 모델을 불변으로 할 수 없기 때문에 출력 기반 테스트에만 의존할 수 없다. 대부분의 경우 출력 기반 스타일과 상태 기반 스타일을 조합하게 되며, 통신 기반 스타일을 약간 섞어도 괜찮다.


# 7장
가치 있는 단위 테스트를 위한 리팩터링

- 도메인 모델과 알고리즘
	- 보통 복잡한 코드는 도메인 모델이지만, 100%는 아니다. 문제 도메인과 직접적으로 관련이 없는 복잡한 알고리즘이 있을 수 있다.
- 지나치게 복잡한 코드
	- 이러한 코드는 두 가지 지표 모두 높다. 협력자가 많으며 복잡하거나 중요하다.

간단한 코드와 컨트롤러는 제외하고 위 두가지 케이스의 단위테스트를 진행하는것이 좋다.
커버리지는 100%를 달성할 수 없으며 이를 목표로 해서는 안된다.

지나치게 복잡한 코드를 쪼개려면, 험블 객체 패턴을 써야한다. 코드가 프레임워크 의존성에 결합돼 있기 때문에 테스트가 어렵다는 사실을 종종 깨달는다.
- 테스트
	- 지나치게 복잡한 코드
		- 테스트하기 어려운 의존성
		- 로직

테스트 대상 코드의 로직을 테스트 하려면, 테스트가 가능한 부분을 추출해야 한다. 결과적으로 코드는 테스트 가능한 부분을 둘러싼 험블 래퍼가 된다.

이하 내용은 예제 코드 위주의 설명.
# 8장
통합 테스트
# 9장
목 처리에 대한 모범 사례
# 10장
데이터베이스 테스트
# 11장
단위 테스트 안티패턴

