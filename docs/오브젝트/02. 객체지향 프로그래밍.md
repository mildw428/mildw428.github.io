---
layout: default
title: 02. 객체지향 프로그래밍
parent: 오브젝트
---
# 02. 객체지향 프로그래밍
---

협력, 객체, 클래스

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다. 이를 위해서는 다음 두 가지에 집중해야 한다.
- 어떤 클래스 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라.
- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

도메인의 구조를 따르는 프로그램 구조
영화 애매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하려는 것이다. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다.

![[Pasted image 20240525141257.png]]

![[Pasted image 20240525142553.png]]

클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.

클래스의 내부와 외부를 구분해야 하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다.

자율적인 객체
객체는 상태와 행동을 함께 가지는 복합적이며, 자율적인 존재이다. 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.

외부에서 접근 가능한 부분을 "퍼블릭 인터페이스" 라고 부른다. 내부에서만 접근 가능한 부분은 "구현" 이라고 부른다. 인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

프로그래머의 자유
프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 구분하는 것이 유용하다. 클라이언트 작성자는 새로운 데이터 타입을 프로그램에 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.

클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것이다. 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다.

>조직에서 이러는건 말도안되는데 이중 인격이 되어야하는걸까?

협력하는 객체들의 공동체
![[Pasted image 20240525144555.png]]
영화를 예매하기 위해 인스턴스들은 서로의 메서드를 호출하며 상호작용한다. 이처럼 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 협력이라고 부른다.

객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.

영화 가격 계산에 참여하는 모든 클래스 사이의 관계를 다이어그램으로 표현한 것이다.
![[Pasted image 20240525144752.png]]
DiscountPolicy 안에 중복 코드를 두고 Amount, Percent클래스가 이 클래스를 상속 받는다. 실제 애플리케이션에서 DiscountPolicy의 인스턴스를 생성할 필요가 없기 때문에 추상클래스로 구현한다.

DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에게 위임한다.

```java
/*
많은 사람들이 오버라이딩(overriding)과 오버로딩(overloading)의 개념을 혼동한다.

오버라이딩은 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우를 가리킨다.

오버로딩은 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다. 

다음은 오버로딩의 예를 나타낸 것이다.
*/
public class Money {
	public Money plus (Money amount) {
		return new Money(this.amount.add (amount.amount));
	｝

	public Money plus(long amount) {
		return new Money(this.amount.add(BigDecimal.valueOf (amount)));
	}
｝
```

할인 정책 구성하기
하나의 영화에 대해 하나의 할인 정책만 설정할 수 있지만, 할인 조건의 경우에는 여러 개를 적용할 수 있다. DiscountPolicy의 생성자는 이런 제약을 강제한다. Movie의 생성자는 오직 하나의 DiscountPolicy 인스턴스만 받을 수 있도록 선언돼 있다.

```java
public abstract class DiscountPolicy {
	public DiscountPolicy (DiscountCondition ... conditions) {
		this.conditions = Arrays.asList(conditions);
	}
}
```

```
#### 추상 클래스(Abstract Class) 사용 시기
1. 공통된 상태를 가질 때:
    - 여러 클래스가 공통된 속성(필드)을 가져야 할 때, 추상 클래스에서 이러한 필드를 정의하고 상속받는 클래스에서 사용할 수 있습니다.
2. 상속받은 클래스에서 기본 동작을 재사용할 때:
    - 추상 클래스는 구현된 메서드를 가질 수 있기 때문에, 공통된 기본 동작을 상속받는 클래스들에서 재사용할 수 있습니다.
3. is-a 관계가 명확할 때:
    - 클래스들 간의 명확한 상속 관계가 있을 때, 추상 클래스가 적합합니다.
4. 생성자와 비정적 초기화 블록이 필요할 때:
    - 추상 클래스는 생성자와 비정적 초기화 블록을 가질 수 있습니다.

#### 인터페이스(Interface) 사용 시기
1. 다중 상속이 필요할 때:
    - Java는 다중 상속을 허용하지 않지만, 인터페이스를 통해 여러 인터페이스를 구현할 수 있습니다.
2. 행위(behavior)를 정의할 때:
    - 인터페이스는 클래스들이 수행해야 하는 행위를 정의할 때 적합합니다.
3. 구현 상속이 필요 없을 때:
    - 인터페이스는 상태(필드)를 가질 수 없고, 오직 상수와 추상 메서드(그리고 Java 8 이후부터는 디폴트 메서드와 static 메서드)를 가질 수 있습니다. 상태를 공유할 필요가 없을 때 사용합니다.
4. 기능 확장이 필요할 때:
    - Java 8 이후부터 인터페이스는 디폴트 메서드를 지원하여, 기존 구현에 영향을 주지 않고 새로운 메서드를 추가할 수 있습니다.
```


```
비정적 초기화 블록(Instance Initialization Block)

1. 정의: 비정적 초기화 블록은 중괄호 `{}` 안에 작성된 코드 블록으로, 객체가 생성될 때 실행됩니다.
2. 구문: 비정적 초기화 블록은 클래스 내에 직접 정의되며, 명시적인 이름이 없습니다.
3. 호출: 객체가 생성될 때마다 생성자 호출 전에 자동으로 실행됩니다. 여러 개의 비정적 초기화 블록이 있는 경우, 정의된 순서대로 실행됩니다.
4. 목적: 여러 생성자에서 공통적으로 실행해야 하는 초기화 코드가 있을 때 유용합니다. 이 블록을 사용하면 코드 중복을 줄일 수 있습니다.
5. 매개변수: 비정적 초기화 블록은 매개변수를 가질 수 없습니다.
```


#### 상속과 다형성
![[Pasted image 20240525220805.png]]
설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장성은 낮아진다. 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다. 무조껀 유연한 설계도, 읽기 쉬운 코드도 정답이 아니다.

##### 차이에 의한 프로그래밍
클래스를 하나 추가하고싶은데 그 클래스가 기존의 어떤 클래스와 매우 흡사하다고 가정해보자. 그 클래스의 코드를 가져와 약간만 추가하거나 수정해서 새로운 클래스를 만들 수 있다면 좋을 것이다. 더 좋은 방법은 클래스의 코드를 전혀 수정하지 않고도 재사용하는 것일 것이다. 이를 가능하게 하는것이 상속이다.

##### 상속과 인터페이스
상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하자. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.  결과적으로 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.

자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 부른다.

##### 다형성
다시 한번 강조하지만 메시지와 메서드는 다른 개념이다.
Movie와 협력하는 객체가 AmountDiscountPolicy 라면 AmountDiscountPolicy에서 오버라이딩한 메서드가 실행될 것이다. PercentDiscountPolicy가 연결된 경우에는 PercentDiscountPolicy에서 오버라이딩한 메서드가 실행될 것이다. 이처럼 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라 부른다.

#### 인터페이스와 다형성
![[Pasted image 20240525220739.png]]
종종 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때가 있다.
추상 클래스를 이용해 다형성을 구현했던 할인 정책과 달리 할인 조건은 구현을 공유할 필요가 없기 때문에 자바의 인터페이스 타입 계층을 구현했다.


#### 추상화의 힘
추상화의 첫 번째 장점은 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것이다. 두 번째 장점은 추상화를 이용하면 설계가 좀 더 유연해진다는 것이다.

새로운 자식 클래스들은 추상화를 이용해서 정의한 상위의 협력 흐름을 그대로 따르게 된다. 이 개념은 매우 중요한데, 재사용 가능한 설계의 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있기 때문이다.

추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

![[Pasted image 20240525222520.png]]

##### 추상 클래스와 인터페이스 트레이드 오프
![[Pasted image 20240525223306.png]]
이상적으로는 인터페이스를 사용하도록 변경한 설계가 더 좋을 것이다. 현실적으로는 NoneDiscountPolicy만을 위해 인터페이스를 추가하는 것이 과하다는 생각이 들 수도 있을 것이다. 어쨋든 변경 전의 NoneDiscountPolicy 클래스 역시 할인 금액이 0원이라는 사실을 효과적으로 전달하기 때문이다.

이 책에서는 설명을 단순화하기 위해 인터페이스를 사용하지 않는 원래의 설계에 기반해서 설명을 이어갈 것이다.
여기서 이야기하고 싶은 사실은 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다는 사실이다. 모든 코드에는 합당한 이유가 있어야 한다.

#### 코드 재사용
상속은 코드를 재사용하기 위해 널리 사용되는 방법이다. 널리 사용되는 방법이라고 해서 가장 좋은 방법인 것은 아니다.코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법이라는 이야기를 많이 들었을 것이다.

합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.

##### 상속
![[Pasted image 20240525223908.png]]
상속은 두 가지 관점에서 설계에 안좋은 영향을 미친다. 하나는 상속이 캡슐화를 위반한다는 것이고, 다른 하나는 설계를 유연하지 못하게 만든다는 것이다.

상속의 가장 큰 문제는 캡슐화를 위반한다는 것이다. 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고있어야 한다.

결과적으로 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 강하게 결합되기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속은 코드를 변경하기 어려워진다.

##### 합성
상속과 다른 점은 상속이 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 데 비해 인터페이스를 통해 약하게 결합된다는 것이다. 실제로 Movie는 DiscountPolicy가 외부에 CalculateDiscountAmount 메서드를 제공한다는 사실만 알고 내부 구현에 대해서는 전혀 알지 못한다. 이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다.
합성은 상속이 가지는 두가지 문제점을 모두 해결한다.

그렇다고 해서 상속을 절대 사용하지 말라는 것은 아니다. 대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.

