---
layout: default
title: 13. 서브클래싱과 서브타이핑
parent: 오브젝트
---
# 13. 서브클래싱과 서브타이핑
---

상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.

타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화 일고 자식 클래스는 부모 클래스의 특수화이다.

상속의 두 번째 용도는 코드 재사용이다. 하지만 재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다.

상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이여야 한다.

올바른 타입 계층을 구성하는 원칙을 살펴보도록 하자.

객체지향 프로그래밍에서 타입의 의미를 이해하려면 프로그래밍 언어 관점에서의 타입과 개념 관점에서의 타입을 함께 살펴볼 필요가 있다.

##### 개념 관점의 타입
우리가 인지하는 세상의 사물의 종류를 의미한다.
어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 부른다. 일반적으로 타입의 인스턴스를 객체라고 부른다. 타입은 세가지 요소로 구성된다. 심볼, 내연, 외연
- 심볼 : 타입에 이름을 붙인 것이다.
	- (ex 프로그래밍 언어)
- 심볼 : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가르킨다.
	- (ex 컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합)
- 외연 : 타입에 속하는 객체들의 집합이다.
	- (ex 자바, 루비, 자바스크립트, C)
##### 프로그래밍 언어 관점의 타입
연속적인 비트에 의미와 제약을 부여하기 위해 사용된다. 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 전적으로 데이터를 사용하는 애플리케이션에 의해 결정된다. 따라서 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.

##### 객체지향 패러다임 관점의 타입
객체지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있다.

#### 타입 계층
수학에서 집합은 다른 집합을 포함할 수 있다. 타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다.

![[Pasted image 20240602132114.png]]

![[Pasted image 20240602132135.png]]
타입계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입이라고 부르고 더 특수한 타입을 서브타입이라고 부른다.

#### 서브클래싱과 서브타이핑
어떤 타입이 다른 타입의 서브타입이 되기 외해서는 어떤 조건을 만족해야 할까?

언제 상속을 사용해야 하는가?
반복 강조하지만 상속의 올바른 용도는 타입 계층을 구현하는 것이다.
- 상속 관계가 is - a 관계를 모델링하는가?
	- 자식 클래스는 부모 클래스다 라고말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
	- 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. 이를 행동 호환성이라고 부른다.


펭귄은 새다
새는 날 수 있다

위 두가지 조건에 따르면 펭귄은 날 수 없기 때문에 상속관계여서는 안된다. 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.

결론은 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다는 것이다. 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.


![[Pasted image 20240602132911.png]]

![[Pasted image 20240602132932.png]]

만약 펭귄이 새의 코드를 재사용해야 한다면 어떻게 해야할까? 합성을 사용하는 것이다. 만약 새의 퍼블릭 인터페이스를 통해 재사용하기 어렵다면 새를 약간 수정해야할 수도 있을것이다. 대부분의 경우에 불안정한 상속 계층을 계속 껴안고 가는 것보다는 새를 재사용 가능하도록 수정하는 것이 더 좋은 방법이다.
![[Pasted image 20240602133210.png]]

이처럼 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙이라고 부른다.

##### 서브클래싱과 서브타이핑
상속을 사용하는 두 가지 목적에 특별한 이름을 붙였는데, 서브클래싱과 서브타이핑이 그것이다.
- 서브클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다. 구현상속 또는 클래스 상속이라고 부르기도 한다.
- 서브타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가르킨다. 인터페이스 상속이라고 부르기도 한다.

서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.
- 사전 조건 : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건
- 사후 조건 : 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건
- 클래스 불변식 : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야하는 조건

하지만 오버라이딩이라는게 존재한다. 자식 객체에서 오버라이딩 할때 더 강력한 사전 조건을 거는 경우 기존 코드에서는 이 사실을 모른다. 때문에 서브타입에 더 강력한 사전 조건을 정의할 수 없다.

하지만 사후 조건은 슈퍼타입과 같거나 더 강한 사후 조건을 걸어도 기존 코드에는 영향이 없다.


