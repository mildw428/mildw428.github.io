---
layout: default
title: 15. 디자인 패턴과 프레임워크
parent: 오브젝트
---
# 15. 디자인 패턴과 프레임워크
---

애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결 방법을 다시 사용하는 경우가 있다. 이처럼 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.

디자인 패턴이 설계를 재사용하기 위한 것이라면 프레임워크는 설계와 코드를 함께 재사용하기 위한것이다.

디자인 패턴과 프레임워크 모두 14장에서 사라펴본 일관성 있는 협력과 관련이 있다.
디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다.
프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드라고 할 수 있다.

#### 디자인 패턴과 설계 재사용

패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징이 있다.
- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른사람과 의사소통할 수 있다.
- 패턴은 추상적인 원인과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

패턴은 홀로 존재하지 않는다. 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있다.

패턴 분류
패턴의 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄 의 4가지로 분류하는 것이다. 4가지 중 가장 널리 알려진 것은 디자인 패턴이다.

디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트 사이에서 반복적으로 발생하는 구조를 서술한다. 디자인 패턴은 중간 규모의 패턴으로, 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.

디자인 패턴 상위에는 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 아키텍쳐 패턴이 위치한다. 아키텍처 패턴은 미리 정의된 서브 시스템들을 제공하고, 각 서브 시스템들의 책임을 정의하며, 서브 시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.

디자인 패턴의 하위에는 이디엄이 위치한다. 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레밸 패턴으로, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다. 이디엄은 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.

분석 패턴은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다. 분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.

패턴과 책임-주도 설계
패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
STRATEGY패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.
BRIDGE패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.
OBSERVER패턴은 유연한 통지 메커니즘을 구축하기 위해 객체간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.


패턴의 구성 요소는 클래스가 아니라 역할이다.
개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE패턴을 살펴보자
![[Pasted image 20240602200339.png]]

패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 방법이 다양하다는 것이다.
![[Pasted image 20240602201143.png]]
![[Pasted image 20240602201151.png]]
두 방법 모두 COMPOSITE패턴에서 제공하는 기본적인 역할과 책임, 협력 관계를 준수한다. 이것은 패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미한다.

캡슐화와 디자인 패턴
몇 가지 이례적인 경우를 제외하면 널리 알려진 대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다.

STRAGTEGY패턴은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.

물론 변경을 캡슐화하는 방법이 합성만 있는 것은 아니다. 상속을 이용할 수도 있다.
![[Pasted image 20240602201446.png]]
이처럼 변경하지 않는 부분은 부모 클래스로, 변경하는 부분은 자식 클래스로 분리함으로써 변경을 캡슐화한다. 알고리즘을 캡슐화 하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것을 TEMPlATE METHOD 패턴이라고 부른다.
![[Pasted image 20240602201559.png]]

다만 합성보다는 결합도가 높은 상속을 사용했기 때문에 STRATEGY패턴 처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다. 하지만 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 STRATEGY패턴보다 복잡도를 낮출 수 있다는 면에서는 장점이라고 할 수 있다.

핸드폰과 과금 시스템 설계는 DECORATOR 패턴을 기반으로 한다.DECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로서 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다.

![[Pasted image 20240602202006.png]]


디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아니다. 어떤 디자인 패턴이 어떤 변경을 캡슐화 하는지를 이해하는 것이 중요하다.

객체의 수를 캡슐화 하는 COMPOSITE 패턴
 COMPOSITE 패턴은 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화하는 것이 목적이다. Movie는 자신과 협력해야 하는 DiscountPolicy인스턴스가 단일 객체인지 복합 객체인지 알 필요가 없다. 다시 말해서 협력하는 객체의 수를 변경하더라도 Movie에 영향을 미치지 않는다.

#### 프레임워크와 코드 재사용

디자인 패턴을 적용하기 위해서는 설계 아이디어를 프로그래밍 언어의 특성에 맞춰 가공해야 하고 매번 구현 코드를 재작성해야 한다는 단점이 있다.

재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다. 오랜 시간 동안 개발자들은 부품을 조립해서 제품을 만드는 것처럼 별도의 프로그래밍 없이 기존 컴포넌트를 조립해서 애플리케이션을 구축하는 방법을 추구해왔다. 아쉽게도 컴포넌트 기반의 재사용 방법이라는 아이디어 자체는 이상적이지만 실제 적용하는 과정에서 현실적이지 않다는 사실이 드러났다.

가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다. 코드만 재사용하는 컴포넌트는 실패했다.

유사한 코드를 반복적으로 구현하는 문제를 피하는 방법 -> 프레임워크

프레임워크란 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계이다.

프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.

##### 상위 정책과 하위 정책으로 패키지 분리하기

프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화라고 할 수 있다.
![[Pasted image 20240602202847.png]]
그림에서 알 수 있는 것처럼 구체적인 클래스들은 RatePolicy, AdditionalRatePolicy, FeeCondition에 의존하지만 추상화들의 구체 클래스에 의존하지 않는다는 것을 알 수 있다.

상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 만약 변하지 않는 상위 정책이 자주 변하는 세부 사항에 의존한다면 변경에 대한 파급 효과로 인해 상위 정책이 불안정해질 것이다. 변하는 것과 변하지 않는 것을 서로 분리해야한다.

이를 위한 첫 걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.![[Pasted image 20240602203133.png]]

##### 제어 역전 원리
상위 정책을 재사용한다는 것은 결국 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미한다.

객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다. 그리고 그 뒤에는 항상 의존석 역전 원리라는 강력한 지원군이 존재한다.

>의존성 역전 원리(Dependency Inversion Principle, DIP)는 객체 지향 설계의 중요한 원칙 중 하나로, 상위 모듈이 하위 모듈에 의존하지 않도록 하여 시스템의 유연성과 유지보수성을 높이는 것을 목표로 합니다. DIP는 다음 두 가지 규칙을 따릅니다
>1. 상위 모듈은 하위 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.
>2. 추상화는 구체적인 것에 의존해서는 안 된다. 구체적인 것이 추상화에 의존해야 한다.


의존성을 역전시킨 객체지향 구조에서는 프레임워크가 애플리케이션에 속하는 서브 클래스의 메서드를 호출한다. 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 즉 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다. 이를 제어 역전원리, 또는 할리우드 원리라고 한다.

![[Pasted image 20240602203805.png]]
핸드폰 과금 시스템의 프레임워크의 요소들을 이용해 기본 정책의 협력을 나타낸 것이다. 그림에서 전체적인 협력 흐름은 프레임워크에 정의돼 있다. 특정한 기본 정책을 구현하는 개발자는 FeeCondition을 대체할 서브타입만 개발하면 프레임워크에 정의된 플로우에 따라 요금이 계산된다.

프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 그리고 이렇게 완성되지 않은 채로 남겨진 동작을 훅 이라고 부른다.

우리의 코드는 수동적인 존재다. 프레임워크가 우리의 코드를 호출해줄 때까지 그저 넋 놓고 기다리고 있을 수밖에 없다. 할리우드에서 캐스팅 담당자가 오디션을 보러 온 배우에게 "먼저 연락하지 마세요.

저희가 연락 드리겠습니다"라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 이야기한다.
