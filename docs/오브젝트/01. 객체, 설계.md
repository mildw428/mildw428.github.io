---
layout: default
title: 01. 객체, 설계
parent: 오브젝트
---
# 01. 객체, 설계
---

티켓 판매 애플리케이션 구현하기
...
각 클래스 구현 생략
...

마틴에 따르면 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다. 앞에서 작성한 프로그램은 관람객들을 입장시키는 데 필요한 기능을 오류 없이 정확하게 수행하고 있다. 따라서 제대로 동작해야 한다는 제약은 만족시킨다. 하지만 불행하게도 변경 용이성과 읽는 사람과의 의사소통이라는 목적은 만족시키지 못한다. 지금부터 그 이유를 살펴보자.

```
소극장은 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 살펴본다. 가방 안에 초대장이 들어 있으면 판 매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다. 가방 안에 초대장이 들어 있지 않다면 관 람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후에 매표소에 보관돼 있는 티켓을 관람객 의 가방 안으로 옮긴다.
```

위 기능에는 문제가 있다. 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점이다.

관람객 입장에서 문제는 소극장이라는 제3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어 본다는 데 있다.

이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다. 앞에서 살펴본 예제는 우리의 예상을 벗어난다.

코드를 이해하기 어렵게 만드는 또다른 이유는 이 코드를 이해하기 위해서는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다는 점이다. Theater의 enter 메서드를 이해하기 위해서는 Audience가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어 있으며 TicketSeller가 TicketOffice에 티켓을 판매하고, TicketOffice안에 돈과 티켓이 보관돼 있다는 모든 사실을 동시에 기억하고 있어야 한다. 이는 코드를 읽고 이해하는 사람에게 큰 부담이다.

가장 심각한 문제는 Audience와 TicketSeller를 변경할 경우 Theater도 함께 변경해야 한다는 사실이다. (변경에 취약하다는 것)

이 코드는 관객이 현금과 초대장을 보관하기 위해 항상 가방을 들고다닌다고 가정한다. 관객이 현금이 아닌 신용카드를 이용해서 결제한다면? 등과 같은 다양한 이유로 모든 코드가 일시에 흔들리게 된다.

이것은 객체 사이의 의존성과 관련된 문제다. 그렇다고 해서 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다. 최소한의 의존성만 유지하고 불필요 한 의존성을 제거해야한다.

![[Pasted image 20240523011538.png]]

해결 방법은 간단하다. Theater가 Audience와 TicketSeller에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다. 

관람객이 가방을 가지고 있다는 사실과 판매원이 매표소에서 티켓을 판매한다는 사실을 Theater가 알아야 할 필요가 없다. Theater가 원하는 것은 관람객이 소극장에 입장하는 것 뿐이다. 

따라서 관람객이 스스로 가방 안의 현금과 초대장을 처리하고 판매원이 스스로 매표소의 티켓과 판매 요금을 다루게 한다면 이 모든 문제를 한 번에 해결할 수 있을 것이다. 

다시 말해서 관람객과 판매원을 자율적인 존재로 만들면 되는 것이다.

![[Pasted image 20240523012402.png]]

![[Pasted image 20240523012545.png]]

판매자가 티켓을 판매하기 위해 TicketOffice를 사용하는 모든 부분을 TicketSeller 내부로 옮기고, 관람객이 티켓을 구매하기 위해 Bag을 사용하는 모든 부분을 Audience 내부로 옮긴 것이다.

핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다. 절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.

절차 지향과 객체 지향 방식의 근본적인 차이를 만드는 것은 책임의 이동이다.

![[Pasted image 20240523013252.png]]

![[Pasted image 20240523013302.png]]

수정한 설계가 이전 설계보다 좋아졌다. 하지만 아직도 개선의 여지가 있다.
Audience의 Bag을 보면 Audience처럼 스스로 자기 자신을 책임지고 있지 않다. Bag을 자율적인 존재로 바꿔보자.

TicketSeller 역시 TicketOffice의 자율권을 침해한다. TicketSeller는 TicketOffice에 있는 Ticket을 마음대로 꺼내서 자기 멋대로 Audience에게 팔고 돈을 집어넣는다.

![[Pasted image 20240523013735.png]]

 직관에 따르는 코드는 이해하기가 더 쉬운 경향이 있다.

그러나 Theater는 어떤가? Bag은? Ticketoffice는? 이들은 실세계에서는 자율적인 존재가 아니다. 그럼에도 우리는 이들을 관람객이나 판매원과 같은 생물처럼 다뤘다. 무생물 역 시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급한 것이다.

현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.

좋은 설계란 무엇일까?
우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다.
요구하는 기능을 온전히 수행하면서 변경을 수용할 수 있는 코드
요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정을 회피하려는 가장 큰 원인은 두려움이다. 두려움은 요구사항 변경으로 인해 버그를 추가할지도 모른다는 불확실성에 기인한다.

따라서 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다. 객체지향은 과거의 다른 방법보다 안정감을 준다

변경 가능한 코드란 이해하기 쉬운 코드다.

객체지향 패러다임은 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다.

훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.

